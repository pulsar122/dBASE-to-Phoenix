/* * This file belongs to dbf.c and is published under the GNU * Library Gerneral Public License (GPL), see COPYING.lib for * details. * * (c) rasca, berlin 1994,'95,'96,'97 (rasca@mozart.komm.hdk-berlin.de) * * not supported: crypted xbase files, reading/writing index files */#ifndef _DBF_H#define _DBF_H#include <stdio.h>#include <limits.h>#ifdef _BUILD_LIB	#include "dbfP.h"#endif#define UCHAR	unsigned char	/* must be 8 bit long *//* modify this to meet your machine dependencies */#if defined (__OS_2_)    #define EXPORT _Export    #define FAR#elif defined (WINDLL)    #define EXPORT  __export    #define PATH_MAX    1024#else    /* unix etc.. */    #define EXPORT    #define FAR	#define DWORD unsigned long     /* must be 32 bit long */	#ifdef WORD	#undef WORD	#endif	#define WORD unsigned short     /* must be 16 bit long */	#define QWORD long long			/* not used until now */	#define word unsigned short#endif#ifndef FALSE    #define FALSE   0    #define TRUE    1#endif/* do not edit below */#define MAX_NAME_LEN    10      /* max length of a field name, do NOT edit!!! */#define CURRENT		0/* needed for the first byte of the header */#define XBASE_VERSION_MASK  0x07#define XBASE_SQL_MASK      0x38#define XBASE_MEMO_MASK     0xC0#define MEMO_DBASE  0x01#define MEMO_FOXPRO 0x02#define DEL_FLAG		'*'#define NOT_DEL_FLAG	' '#define bit(x,p) ((x >> p)&0x01)/* field types */#define FT_CHARS    'C'#define FT_DATE     'D'#define FT_FLOAT    'F'#define FT_BOOLEAN  'L'		/* fixed width: 1 */#define FT_MEMO     'M'		/* fixed width: 10 */#define FT_NUMBER   'N'		/* integer field */#define FT_GENERAL  'G'		/* foxpro + dBASE 5.0fw - not supported!*/#define FT_BINARY	  'B'		/* dBASE 5.0 for windows */#define FT_OBJECT	  'O'		/* delphi/borland */#define FT_PICTURE	'P'		/* foxpro picture */#define FT_UNKNOWN  '\0'/* date formats */#define DF_DD_MM_YYYY	0x01	/* day, month, year */#define DF_MM_DD_YYYY	0x02#define DF_YYYYMMDD		0x04#define DF_YYYYMMDD_I	0x08	/* it's yyyymmdd as an integer *//* * structure of a dbase III+, IV database header of the file */typedef struct _db_header {	UCHAR type;         /* bit 0-2 = version number, 3-5 SQL, 6-7 */	UCHAR lm_yy;        /* last modification (year) */	UCHAR lm_mm;        /* last modification (month) */	UCHAR lm_dd;        /* last modification (day) */	DWORD num_of_recs;	/* 32 bit, number of entries */	WORD  header_size;	/* 16 bit, size of the header */	WORD  record_size;	/* 16 bit, size of a record */	UCHAR reserved1[2]; /* 2 bytes, reserved - filled with 0 */	UCHAR transaction;  /* 1 byte, mark for not ended transactions */	UCHAR crypted;      /* 1 byte, mark for cryption (dBASE IV) */	UCHAR net[12];      /* 12 bytes, reserved for dBASE IV+5.0 network version */	UCHAR mdx;          /* 1 byte, 1 = MDX is there, 0 = no MDX-file */	UCHAR code;			/* foxpro, dBASE IV2.0, 5.0 save here information about the code page */	UCHAR reserved2[2]; /* 2 bytes, reserved */} db_header;	/* about the code flag (language driver id):		0x01	U.S. MS-Dos              437		0x02	International MS-Dos     850		0x03	Windows ANSI            1251		0xC8	Windows EE              1250		..	*//* * structure of the following field descriptions in the file */typedef struct _db_field_desc {	UCHAR name[MAX_NAME_LEN+1];	/* fieldname, ascii coded   */	UCHAR type;						/* field type (C, D, F, L, M, N), ascii coded */	WORD  offset;					/* offset from beginning of record, foxpro? */	UCHAR reserved1[2];		/* reserved */	UCHAR length;					/* length of the field  */	UCHAR dec_num;				/* number of decimal places */	UCHAR reserved2[2];		/* reserved for multi-user dBASE */	UCHAR work_id;				/* ID of the working area   */	UCHAR reserved3[2];		/* reserved for multi-user dBASE */	UCHAR set_fields;			/* flag for SET FIELDS */	UCHAR reserved4[7];		/* reserved */	UCHAR mdx_tag;				/* 01H:  has tag in production MDX, 00H: has not */} db_field;/* * for index files (not used, because i need more technical stuff..) */typedef struct _ndx {	DWORD root_page;	/* start key page */	DWORD total;		/* total pages */	UCHAR reserved[4];  /* reserved .. */	WORD  key_len;		/* index key length */	WORD  max_page;		/* max key page */	WORD  type;			/* ndx key type */	DWORD size;			/* size of a key record */	UCHAR reserved2;	/* reserved .. */	UCHAR unique;		/* unique flag */	UCHAR key_name[488];/* key name */} db_ndx;/* */typedef struct _ndx_key {	DWORD page_num;	/* points to the next page in the b-tree left of the key */	DWORD rec_num;	/* points to the record number of the dbf file */	UCHAR *key;		/* has the length of db_ndex.size */} ndx_key;/* */typedef struct _ndx_page {	DWORD   rec_num;	/* number of key entries */	ndx_key **keys;		/* points to 'rec_num' entries of ndx_key structures */} db_ndx_page;/* */typedef struct _mdx {	char who_knows;} db_mdx;/* * memo file stuff is still not ready :-( */typedef struct _memo {	DWORD next_free;			/* points to the next free memo entry */			DWORD block_size;			/* not known until now :( */	UCHAR fill[512-8];			/* fill bytes in the header */	int type;					/* could be MEMO_DBASE or MEMO_FOXPRO */	char file_name[PATH_MAX];	/* filename of the memo-file */	FILE *fp;					/* file pointer for the memo file */} db_memo;/* */typedef struct _memo_entry {	DWORD num;		/* what is this? it seems to be always "1" */	DWORD len;		/* length of the memo entry */	char *buf;		/* buffer for writing / reading .. */} db_memo_entry;/* */typedef struct _idx {	DWORD root;		/* start key page */	DWORD free;	DWORD eof;	WORD  key_len;	UCHAR opt;	UCHAR key[497];} db_idx;/* */typedef struct _cdx {	char who_knows;} db_cdx;/* */typedef struct _index {	DWORD	flags;	db_idx	header;	FILE	*fp;} db_index;/* * for the list of open dbf-files */typedef struct _dbf {	char file_name[PATH_MAX];	/* file name of the open xbase file */	FILE *fp;               /* file pointer of the opened xbase file  */	WORD num_of_fields;     /* number of fields */	DWORD current;			/* current record number */	int access_mode;        /* read / write mode */	int handle;				/* index / handle for the file */	int memoflag;			/* has or has no memo file */	db_memo	*memo;			/* pointer to the memo-file structure */	WORD	*offset;		/* for faster position calculating of fields */	db_index  *idx;			/* pointer to the index structure */	db_header *head;        /* pointer to the structure of the header */	db_field  **fields;     /* pointer to the structure of the fields */} DBF;#define EO_FDESC    ((UCHAR) 0x0D)/* access modes */#define DB_READ			0x01	/* it's obsolete :) */#define DB_WRITE		0x02	/* must be set writing sould be allowed */#define DB_IGNORE_MEMO	0x04#define DB_IGNORE_MDX	0x08#define DB_IGNORE_DEL	0x10#define DB_DBASE3		0x20	/* dbase III+ */#define DB_DBASE4		0x40	/* dbase IV */#define DB_FOXPRO		0x80	/* foxpro 2.x *//* return error codes */#define E_HANDLE			-1#define E_REC_NR			-2#define E_FLD_NR			-3#define E_FLD_TYPE		-4#define E_IO			  	-5#define E_ALLOC				-6#define E_VERSION			-7#define E_HEADER			-8#define E_WRONG_MODE	-9#define E_UNKNOWN			-10/* * the API functions: *//* * open a xbase-file */extern int FAR EXPORT dbOpen (char* fname, int mode);/* * create a new dbf file, not ready until now!  */int FAR EXPORT dbCreate (char *fname, WORD num_of_fields, UCHAR type);/* * close a xbase-file, returns FALSE if no file is open correponding * to 'handle' */int FAR EXPORT dbClose (int handle);/* * moves the db_file pointer to Nr, a following dbRawNext() will * read record Nr */int FAR EXPORT dbGotoNr (int handle, DWORD where);/* * goes 'offset' record backward or forward */int FAR EXPORT dbWind (int handle, long int offset);/* * returns the number of record in the file */DWORD FAR EXPORT dbGetNumOfRecs (int handle);/* * returns the number of fields */int FAR EXPORT dbGetNumOfFields (int handle);/* * returns the length of the num-th field */int FAR EXPORT dbGetFieldLength (int handle, WORD num);/* * returns the field type */char FAR EXPORT dbGetFieldType (int handle, WORD num);/* * returns the number of the named field */int EXPORT dbGetFieldNum (int handle, const char *name);/* * returns the number of decimal places */int FAR EXPORT dbGetFieldDec (int handle, WORD num);/* * get the name of the num-th field */const UCHAR FAR *dbGetFieldName (int handle, WORD num);/* * read next and return a pointer to the raw datas, NO ending '\0' is * at the end! 'int *' returns the length */UCHAR FAR* EXPORT dbRawNext (int handle, WORD *num);UCHAR FAR* EXPORT dbRawField (int handle, WORD num);/* * read next and return a converted (trimmed) string line * seperated by 'seperator' incl. an closing '\0' */UCHAR FAR EXPORT *dbTrStrNext (int handle, char seperator);/* * read the n-th field from the actuall record, white spaces are trimmed */UCHAR FAR EXPORT *dbTrSelByNumber (int handle, WORD num, int wind);/* * read the n-th field from the actuall record */UCHAR FAR EXPORT *dbSelByNumber (int handle, WORD num, int wind);/* * read the field 'field' from the actuall record */UCHAR FAR EXPORT *dbTrSelByName (int handle, const char* field, int wind);/* * set the configuration for the dbf file named by 'handle' * whether deleted record should be shown */int FAR EXPORT dbSetShowDel (int handle, int mode);/* * init a new field in a new dbf file, not ready until now!  */int FAR EXPORT dbInitField (int handle, WORD num, UCHAR *name, UCHAR type, UCHAR length, UCHAR dec_num);/* * add a new empty record */DWORD FAR EXPORT dbAppendBlank (int handle);/* * return the current position */DWORD FAR EXPORT dbCurrent (int handle);/* * change a field of a record */int FAR EXPORT dbChangeField (int handle, DWORD nr, WORD num, char *data);/* * change a field of a record - not ready! */int FAR EXPORT dbChangeFieldRaw (int handle, DWORD nr, WORD num, void *data);/* * delete a record */int FAR EXPORT dbDelRecord (int handle, DWORD nr);/* * undelete a record */int FAR EXPORT dbUndelRecord (int handle, DWORD nr);/* * use memo files .. */int FAR EXPORT dbSetUseMemo (int handle, int mode);/* * get some informations from the opened file (e.g. DB_IGNORE_MEMO etc..) */int FAR EXPORT dbGetMode (int handle);/* * get the field name incl. spaces up to MAX_NAME_LEN */UCHAR FAR EXPORT *dbGetExFieldName (int handle, WORD num);/* * get the next not striped record */UCHAR FAR EXPORT *dbStrNext (int handle, char seperator);/* * pack a xbase file */int FAR EXPORT dbPack (int handle);/* * restore (unpack) a xbase file */int FAR EXPORT dbRestore (int handle);/* * copy named fields to a new file */int FAR EXPORT dbCopyToFile (int handle, WORD *flds, WORD num, char *fname);/* * ask if a record is deleted */int FAR EXPORT dbIsDeleted (int handle, DWORD num);/* * dump the header .. for debbuging .. */int dbDumpHeader (int handle);/* */char FAR EXPORT dbDefDateSep(void);/* */int FAR EXPORT dbGetType(int handle);/* */char FAR EXPORT *dbLastUpdate(int handle);/* */int EXPORT dbEof(int handle);/* */extern int dberrno;#endif /* _DBF_H */