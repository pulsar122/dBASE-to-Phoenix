								1dbf(3)		Manual for Version 0.7		dbf(3)NAME       libdbf.a - simple routines for accessing xbase data filesSYNOPSIS       #include <dbf.h>       int dbOpen (char *path, int mode);       int dbCreate (const char *path, WORD nof, UCHAR type);       int dbClose (int handle);       int  dbInitField (int handle, WORD fnr, UCHAR *name, UCHAR       type, UCHAR length, UCHAR dec);       int dbGotoNr (int handle, DWORD num);       int dbWind (int handle, long int offset);       DWORD dbGetNumOfRecs (int handle);       int dbGetNumOfFields (int handle);       int dbGetFieldLength (int handle, WORD num);       char dbGetFieldType (int handle, WORD num);       int dbGetFieldNum (int handle, const char *name);       int dbGetFieldDec (int handle, WORD num);       const UCHAR *dbGetFieldName (int handle, WORD num);       UCHAR *dbGetExFieldName (int handle, WORD num);       UCHAR *dbRawNext (int handle, WORD *num);       UCHAR *dbTrStrNext (int handle, char seperator);       UCHAR *dbStrNext (int handle, char seperator);       UCHAR *dbSelByNumber (int handle, WORD num, int go);       UCHAR *dbTrSelByNumber (int handle, WORD num, int go);       UCHAR *dbTrSelByName (int handle,  const	char  *fld,  int       go);       int dbSetShowDel (int handle, int mode);       int dbSetUseMemo (int handle, int mode);       int  dbChangeField  (int	handle, DWORD rn, WORD fn, const       char *s);       int dbChangeFieldRaw (int handle,  DWORD	rnr,  WORD  fnr,       const void *data);       int dbDelRecord (int handle, DWORD record_number);       int dbUndelRecord (int handle, DWORD record_number);       int dbGetMode (int handle);       int dbGetType (int handle);       char *dbLastUpdate(int handle);       int dbPack (int handle);       int dbRestore (int handle);       int  dbCopyToFile (int handle, WORD *flds, WORD num, const       char *path);       int dbIsDeleted (int handle, DWORD record_number);       int dbEof (int handle);       DWORD dbAppendBlank (int handle);       DWORD dbCurrent (int handle);       This library is designed to  access  xBase  files  (dBase,       FoxPro,	..).   dBASE  II  files are not and will never be       supported!  Until now it is still in  ALPHA  state!  Index       files  are  not	supported and all other functions are not       testet very well. The foxpro object field type is not sup       ported. The API is still in design phase also the handlingGNU			27 Mar 1997				1dbf(3)		Manual for Version 0.7		dbf(3)       of errors and the concept of return codes! The source code       and  the	example  programs  are	published  under the GNU       Librabry General Public License and the GNU General Public       License.	To  extend  the  library  i need more technical       informations about the file formats. If you can	help  me,       please  email  ..  (see	the end of the man-page for email       addresses).       int dbOpen (char *path, int mode);       Opens the xbase-file path and returns an	integer  as  the       handle  for referencing this file due next operations. The       variable mode could be DB_READ, DB_WRITE,  DB_IGNORE_MEMO,       DB_IGNORE_MDX,  DB_IGNORE_DEL and DB_FOXPRO. If you choose       more then one argument they  must  be  ored.   DB_READ  is       obsolet	if you use DB_WRITE.  DB_WRITE with memo files is       not very well tested :(. Have a look at	the  end  of  the       man-page	for  the error codes. For an example how to call       the function see EXAMPLE in the man-page.       int dbCreate (const char *path, WORD nof, UCHAR type);       Creates a new xbase file, nof is	the  number  of  fields.       type  must  be  DB_DBASE3,  DB_DBASE4  or DB_FOXPRO. After       calling dbCreate() you  have  to	call  dbInitField()  for       every  field in the new xbase file to specify type, length       etc.. The function returns the handle  of  the  new  xbase       file  on success or E_FLD_NR, E_IO, E_ALLOC or E_HANDLE on       failure.       int dbClose (int handle);       This function closes a xbase-file. It returns TRUE on suc       cess or E_IO, E_HANDLE on failure. See below for the error       codes.       int dbInitField (int handle, WORD fnr, UCHAR *name,  UCHAR       type, UCHAR length, UCHAR dec);       Change  the  type  etc. of a new field. If the name of the       field is too long it is striped to 10 characters. Use this       function	immeditly  after  a  dbCreate() call. If you use       this function for a existing xbase file or after appending       the first record you will run into an error (return value:       FALSE)!	Valid  field  types   are:   FT_CHARS,	FT_DATE,       FT_FLOAT,   FT_BOOLEAN,	FT_MEMO,  FT_NUMBER,  FT_BINARY,       FT_GENERAL  and	FT_OBJECT.   FT_BINARY,	FT_GERNERAL  and       FT_OBJECT are not handled correct!.       int dbGotoNr (int handle, DWORD num);       Moves  the  internal  file  pointer  to	num,  a following       dbRawNext() will read record num.  On success  it  returns       TRUE. On failure it returns E_HANDLE or E_REC_NR.GNU			27 Mar 1997				2dbf(3)		Manual for Version 0.7		dbf(3)       int dbWind (int handle, long int offset);       Goes  offset records backward or forward in the file which       belongs to handle.  dbWind  returns  TRUE  on  success  or       E_HANDLE, E_REC_NR or E_IO on error.       DWORD dbGetNumOfRecs (int handle);       Returns	the  number  of records in the table specified by       handle.	Deleted records	are  also  counted.  On  failure       dberrno is set to E_HANDLE and the return value is 0.       int dbGetNumOfFields (int handle);       Returns	the  number  of	fields of the file pointed to by       handle.	If handle has a wrong value it returns	E_HANDLE.       int dbGetFieldLength (int handle, WORD num);       Returns	the  length  of	the  num-th  field.  It  returns       E_HANDLE if the handle is wrong and E_FLD_NR if num is not       ok.  If	the type of the field is FT_MEMO or FT_OBJECT not       the length of the memo entry is returned but the length of       the  field  in the xbase file where the memo record number       is stored. This is for memo and for object fields all  the       time '10'.       char dbGetFieldType (int handle, WORD num);       Returns	the type of the field in handle.  Could be one of       FT_CHARS,   FT_DATE,   FT_FLOAT,	FT_BOOLEAN,	FT_MEMO,       FT_NUMBER, FT_BINARY, FT_OBJECT, FT_GENERAL or FT_UNKNOWN.       int dbGetFieldNum (int handle, const char *name);       Returns the number of the named field. This number is used       by  the most API functions to identify a field in a table.       int dbGetFieldDec (int handle, WORD num);       Returns the decimal places of the field in handle.       const UCHAR *dbGetFieldName (int handle, WORD num);       Returns the name of the num-th field. The return value  is       NULL if some errors are occurred.       UCHAR *dbGetExFieldName (int handle, WORD num);       returns the name of the field expaned to the lenght of the       field and padded with spaces. If the field width	is  less       than  the  length  of  the  field  name	the  width of the       returned	string	is  expanded  to  10.	The  function  isGNU			27 Mar 1997				3dbf(3)		Manual for Version 0.7		dbf(3)       desigend for formated output.       UCHAR *dbRawNext (int handle, WORD *num);       Reads the next record from handle and returns a pointer to       the raw data. Cause the result string could  also  contain       non  ascii characters the length of the returned string is       saved in the num variable.  After using the pointer  which       is returned you must clean it with free(3).       UCHAR *dbTrStrNext (int handle, char seperator);       Reads  the next record from handle and returns a converted       char line seperated by seperator incl. a closing '\0'.  At       the  end	of  the  file	a  NULL is returned.  If the next       record is a deleted record and dbSetShowDel()  is  set  to       FALSE a '\0' is returned (default: show deleted records!).       After using the pointer which is returned you  must  clean       it with free(3).       UCHAR *dbStrNext (int handle, char seperator);       Is the non-stripping version. It ignores memo-files, cause       the field length of memo-fields are not fixed!       UCHAR *dbSelByNumber (int handle, WORD num, int go);       Read the num-th field from the next record of handle.   If       go  is  FALSE  the function will not go to the next record       after reading.  After using the pointer which is	returned       you must clean it with free(3).	The function returns NULL       if the record couldn't be read (e.g.  EOF),  '\0'  if  the       record is deleted or the field if all is ok.       UCHAR *dbTrSelByNumber (int handle, WORD num, int go);       Read  the num-th field from the next record of handle.  If       go is FALSE the function will not go to	the  next  record       after  reading.	After using the pointer which is returned       you must clean it with free(3).	White spaces are trimmed.       Date fields are converted to DD-MM-YYYY.       UCHAR  *dbTrSelByName  (int handle, const char* field, int       go);       Read the field field from the next record of  handle.   If       go  is  FALSE  the function will not go to the next record       after reading.  After using the pointer which is	returned       you must clean it with free(3).	White spaces are trimmed.       Date fields are converted to DD-MM-YYYY.       int dbSetShowDel (int handle, int mode);       Sets whether deleted  records  should  be  shown	or  not,GNU			27 Mar 1997				4dbf(3)		Manual for Version 0.7		dbf(3)       default	is  TRUE.   Normaly  you set this while opening a       xbase   file   and   give   the	correct    mode,    e.g.       dbOpen("foo.dbf",  DB_READ  |  DB_IGNORE_DEL). But you can       also use this function  to  switch  at  runtime.	Possible       arguments are TRUE and FALSE.       int dbSetUseMemo (int handle, int mode);       Sets  whether  a	memo  file,  which belongs to the table,       should be ignored or not.  mode must be TRUE or FALSE.       DWORD dbAppendBlank (int handle);       Adds a new record. Returns FALSE if an error occurred.  In       this  situation	the  extern  variable 'dberrno' is set to       E_HANDLE, E_WRONG_MODE or to E_ALLOC.  On success the num       ber of the new record is returned.       int  dbChangeField  (int handle, DWORD rnr, WORD fnr, char       *data);       Change the content of a field. data  is	a  pointer  to	a       string  which  contains	the new information of the field.       dbChangeField() converts this to the  corresponding  field       type.   rnr is the record number and fnr is the field num       ber which should be changed. For date fields  data  should       be a string like "DD-MM-YYYY" or "DD.MM.YYYY". Return val       ues: TRUE, FALSE, E_REC_NR, E_HANDLE, E_FLD_TYPE, E_ALLOC.       dbChangeRaw() doesn't work until now.       int dbDelRecord (int handle, DWORD record_number);       Delete  a  record  in the xbase file. The record is marked       with a '*' at the beginning. While not using  dbPack()  or       overwriting  the	record	you can restore it with dbUndel       Record(). On success it returns TRUE.       int dbUndelRecord (int handle, DWORD record_number);       Undelete a record in the xbase file. The record is  marked       with a ' ' (space). On success it returns TRUE.       int dbGetMode (int handle);       Returns	the  access  mode of the file: DB_READ, DB_WRITE,       DB_IGNORE_MEMO, DB_IGNORE_MDX, DB_IGNORE_DEL.       int dbGetType (int handle);       Returns the type of table: 0x03, ..       char *dbLastUpdate(int handle);       Gives a string which contains the  date	of  last  update.GNU			27 Mar 1997				5dbf(3)		Manual for Version 0.7		dbf(3)       Pointer must be freed.       DWORD dbCurrent (int handle);       Returns the current position of the internal pointer.       int dbPack (int handle);       Packs  a	xbase	file.  It meens all undeleted records are       moved to the beginning of the file and  the  EOF	mark  is       moved  after the last not deleted record. The file size is       not changed but the number of records  in  the  header  is       down  counted to the number of not deleted records.  After       using this funktion you can not undelete a deleted record.       int dbRestore (int handle);       In short hands it is an undo of dbPack(). It moves the EOF       mark in the xbase file to the physical end of the file and       increases accordingly the number of records in the header.       This could result in double records!  Don't use it if  you       don't know about what exactly happens!       int  dbCopyToFile (int handle, WORD *flds, WORD num, const       char *path);       Copies named fields to a new xbase file.	The  fields  are       named  by  theire  number  and must be stored in flds.  To       give the function the information how much  field  numbers       are stored in flds use num.  If num is '0' all fields will       be copied and flds will be  ignored.   path  contains  the       file name of the new xbase file.       int dbIsDeleted (int handle, DWORD record_number);       Checks if a record is deleted. Use the macro 'CURRENT' for       record_number, to check the current record.  The	function       returns	TRUE  if the specified record is deleted or FALSE       if not.       int dbEof (int handle);       Returns TRUE if the pointer is behind the last record else       FALSE  also  if	there was an error (dberrno is set to the       error value).RETURN VALUES       All return values are negative values. Don't forget to use       signed variables to handle these return codes.       E_HANDLE       Wrong  handle  specified.  Use  onle the handles which are       returned by dbOpen() or dbCreate().GNU			27 Mar 1997				6dbf(3)		Manual for Version 0.7		dbf(3)       E_REC_NR       Wrong record number, the specified record does not  exist.       E_FLD_NR       Wrong  field number, the specified field does not exist or       you give a number of fields = 0 to dbCreate().       E_FLD_TYPE       Wrong field type, the specified field type is not ok.       E_IO       I/O error while accessing a xbase  file,	e.g.  'file  not       found', 'permission denied', etc..       E_ALLOC       Memory  allocation  error,  there is too less memory for a       malloc() or alloc() call.       E_VERSION       Wrong xbase file version.       E_WRONG_MODE       A function tried to make a write access to  a  file  while       this was oppend in read-mode.       E_HEADER       An error in the header of the xbase file was found.       E_UNKNOWN       An unknown error :)EXAMPLE       /*	* mini demo for the libdbf.a, converts a dbf to an ascii flat file	* rasca, berlin 1996	*/       #include <stdlib.h> /* free() */       #include <stdio.h>  /* cause of dbf.h and printf() */       #include "dbf.h"	/* dbOpen(), dbStrNext(), dbClose() */       int main (int argc, char **argv) {	    int db;	    char *s;	    if (argc > 1) {		 if ((db = dbOpen (argv[1], DB_READ)) > 0) {		      while ((s = dbTrStrNext(db, ';')) != NULL) {			   printf ("%s\n", s);			   free (s);		      }		      dbClose (db);		 }GNU			27 Mar 1997				7dbf(3)		Manual for Version 0.7		dbf(3)	    }	    return (0);       }BUGS       libdbf has 10^12 * 3.1415 bugs or more :-)TODO       functions  for  modifying and creating index files, better       man-pages :) etc..AUTHOR       Rasca Gmelch	 InterNet: rasca@mozart.komm.hdk-berlin.de	 World WW: http://home.pages.de/~rasca/	 linuxNet: rasca@lupo.cib.linuxnet.org	 Fido-Net: Rasca Gmelch, 2:2410/305.4GNU			27 Mar 1997				8