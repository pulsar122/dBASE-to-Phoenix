!raw [stg] @subject "Dokumentation"

!code [tos]
!language german

!docinfo [title] Die Anleitung zu
!docinfo [program]    Manual for Version 0.7
!docinfo [version]    Version 0.07
!docinfo [date]     (!today)
!docinfo [author] Gerhard Stoll
!docinfo [address] Jahnstr. 8
!docinfo [address] D-67547 Worms am Rhein
!docinfo [address] MausNet: Gerhard Stoll @ LU

########################################
# Schalter setzen
########################################
!use_short_tocs			[stg,win,html,pch]
!use_auto_subtocs		[stg,win,html,pch]
!use_auto_subsubtocs	[stg,win,html,pch]
!use_auto_subsubsubtocs	[stg,win,html,pch]
!use_nodes_inside_index  [win, stg]
!use_label_inside_index [win, stg]
!no_effects				[asc]


!begin_document


!maketitle
!tableofcontents

!node Einleitung

       This library is designed to  access  xBase  files  (dBase,
       FoxPro,	..).   dBASE  II  files are not and will never be
       supported!  Until now it is still in  ALPHA  state!  Index
       files  are  not	supported and all other functions are not
       testet very well. The foxpro object field type is not sup
       ported. The API is still in design phase also the handling
       of errors and the concept of return codes! The source code
       and  the	example  programs  are	published  under the GNU
       Librabry General Public License and the GNU General Public
       License.	To  extend  the  library  i need more technical
       informations about the file formats. If you can	help  me,
       please  email  ..  (see	the end of the man-page for email
       addresses).

!node dbOpen()

      int dbOpen (char *path, int mode);

       Opens the xbase-file path and returns an	integer  as  the
       handle  for referencing this file due next operations. The
       variable mode could be DB_READ, DB_WRITE,  DB_IGNORE_MEMO,
       DB_IGNORE_MDX,  DB_IGNORE_DEL and DB_FOXPRO. If you choose
       more then one argument they  must  be  ored.   DB_READ  is
       obsolet	if you use DB_WRITE.  DB_WRITE with memo files is
       not very well tested :(. Have a look at	the  end  of  the
       man-page	for  the error codes. For an example how to call
       the function see EXAMPLE in the man-page.

!node dbCreate()
      int dbCreate (const char *path, WORD nof, UCHAR type);

       Creates a new xbase file, nof is	the  number  of  fields.
       type  must  be  DB_DBASE3,  DB_DBASE4  or DB_FOXPRO. After
       calling dbCreate() you  have  to	call  dbInitField()  for
       every  field in the new xbase file to specify type, length
       etc.. The function returns the handle  of  the  new  xbase
       file  on success or E_FLD_NR, E_IO, E_ALLOC or E_HANDLE on
       failure.

!node dbClose()
       int dbClose (int handle);

       This function closes a xbase-file. It returns TRUE on suc
       cess or E_IO, E_HANDLE on failure. See below for the error
       codes.

!node  dbInitField()

       int dbInitField (int handle, WORD fnr, UCHAR *name,  UCHAR
       type, UCHAR length, UCHAR dec);

       Change  the  type  etc. of a new field. If the name of the
       field is too long it is striped to 10 characters. Use this
       function	immeditly  after  a  dbCreate() call. If you use
       this function for a existing xbase file or after appending
       the first record you will run into an error (return value:
       FALSE)!	Valid  field  types   are:   FT_CHARS,	FT_DATE,
       FT_FLOAT,   FT_BOOLEAN,	FT_MEMO,  FT_NUMBER,  FT_BINARY,
       FT_GENERAL  and	FT_OBJECT.   FT_BINARY,	FT_GERNERAL  and
       FT_OBJECT are not handled correct!.

!node  dbGotoNr()
       int dbGotoNr (int handle, DWORD num);

       Moves  the  internal  file  pointer  to	num,  a following
       dbRawNext() will read record num.  On success  it  returns
       TRUE. On failure it returns E_HANDLE or E_REC_NR.

!node  dbWind()

       int dbWind (int handle, long int offset);

       Goes  offset records backward or forward in the file which
       belongs to handle.  dbWind  returns  TRUE  on  success  or
       E_HANDLE, E_REC_NR or E_IO on error.

!node  dbGetNumOfRecs()

       DWORD dbGetNumOfRecs (int handle);

       Returns	the  number  of records in the table specified by
       handle.	Deleted records	are  also  counted.  On  failure
       dberrno is set to E_HANDLE and the return value is 0.

!node  dbGetNumOfFields()
       int dbGetNumOfFields (int handle);

       Returns	the  number  of	fields of the file pointed to by
       handle.	If handle has a wrong value it returns	E_HANDLE.

!node  dbGetFieldLength()
       int dbGetFieldLength (int handle, WORD num);

       Returns	the  length  of	the  num-th  field.  It  returns
       E_HANDLE if the handle is wrong and E_FLD_NR if num is not
       ok.  If	the type of the field is FT_MEMO or FT_OBJECT not
       the length of the memo entry is returned but the length of
       the  field  in the xbase file where the memo record number
       is stored. This is for memo and for object fields all  the
       time '10'.

!node  dbGetFieldType()
       char dbGetFieldType (int handle, WORD num);

       Returns	the type of the field in handle.  Could be one of
       FT_CHARS,   FT_DATE,   FT_FLOAT,	FT_BOOLEAN,	FT_MEMO,
       FT_NUMBER, FT_BINARY, FT_OBJECT, FT_GENERAL or FT_UNKNOWN.

!node  dbGetFieldNum()
       int dbGetFieldNum (int handle, const char *name);

       Returns the number of the named field. This number is used
       by  the most API functions to identify a field in a table.

!node  dbGetFieldDec()
       int dbGetFieldDec (int handle, WORD num);

       Returns the decimal places of the field in handle.

!node  dbGetFieldName()
       const UCHAR *dbGetFieldName (int handle, WORD num);

       Returns the name of the num-th field. The return value  is
       NULL if some errors are occurred.


!node  dbGetExFieldName()
       UCHAR *dbGetExFieldName (int handle, WORD num);

       returns the name of the field expaned to the lenght of the
       field and padded with spaces. If the field width	is  less
       than  the  length  of  the  field  name	the  width of the
       returned	string	is  expanded  to  10.	The  function  is
       desigend for formated output.

!node  dbRawNext()
       UCHAR *dbRawNext (int handle, WORD *num);

       Reads the next record from handle and returns a pointer to
       the raw data. Cause the result string could  also  contain
       non  ascii characters the length of the returned string is
       saved in the num variable.  After using the pointer  which
       is returned you must clean it with free(3).

!node  dbTrStrNext()
       UCHAR *dbTrStrNext (int handle, char seperator);

       Reads  the next record from handle and returns a converted
       char line seperated by seperator incl. a closing '\0'.  At
       the  end	of  the  file	a  NULL is returned.  If the next
       record is a deleted record and dbSetShowDel()  is  set  to
       FALSE a '\0' is returned (default: show deleted records!).
       After using the pointer which is returned you  must  clean
       it with free(3).

!node  dbStrNext()
       UCHAR *dbStrNext (int handle, char seperator);

       Is the non-stripping version. It ignores memo-files, cause
       the field length of memo-fields are not fixed!

!node  dbSelByNumber()
       UCHAR *dbSelByNumber (int handle, WORD num, int go);

       Read the num-th field from the next record of handle.   If
       go  is  FALSE  the function will not go to the next record
       after reading.  After using the pointer which is	returned
       you must clean it with free(3).	The function returns NULL
       if the record couldn't be read (e.g.  EOF),  '\0'  if  the
       record is deleted or the field if all is ok.

!node  dbTrSelByNumber()
       UCHAR *dbTrSelByNumber (int handle, WORD num, int go);

       Read  the num-th field from the next record of handle.  If
       go is FALSE the function will not go to	the  next  record
       after  reading.	After using the pointer which is returned
       you must clean it with free(3).	White spaces are trimmed.
       Date fields are converted to DD-MM-YYYY.

!node  dbTrSelByName()
       UCHAR  *dbTrSelByName  (int handle, const char* field, int go);

       Read the field field from the next record of  handle.   If
       go  is  FALSE  the function will not go to the next record
       after reading.  After using the pointer which is	returned
       you must clean it with free(3).	White spaces are trimmed.
       Date fields are converted to DD-MM-YYYY.

!node  dbSetShowDel()
       int dbSetShowDel (int handle, int mode);

       Sets whether deleted  records  should  be  shown	or  not,
       default	is  TRUE.   Normaly  you set this while opening a
       xbase   file   and   give   the	correct    mode,    e.g.
       dbOpen("foo.dbf",  DB_READ  |  DB_IGNORE_DEL). But you can
       also use this function  to  switch  at  runtime.	Possible
       arguments are TRUE and FALSE.

!node  dbSetUseMemo()
       int dbSetUseMemo (int handle, int mode);

       Sets  whether  a	memo  file,  which belongs to the table,
       should be ignored or not.  mode must be TRUE or FALSE.

!node  dbAppendBlank()
       DWORD dbAppendBlank (int handle);

       Adds a new record. Returns FALSE if an error occurred.  In
       this  situation	the  extern  variable 'dberrno' is set to
       E_HANDLE, E_WRONG_MODE or to E_ALLOC.  On success the number
       of the new record is returned.

!node  dbChangeField()
       int  dbChangeField  (int handle, DWORD rnr, WORD fnr, char
       *data);

       Change the content of a field. data  is	a  pointer  to	a
       string  which  contains	the new information of the field.
       dbChangeField() converts this to the  corresponding  field
       type.   rnr is the record number and fnr is the field num
       ber which should be changed. For date fields  data  should
       be a string like "DD-MM-YYYY" or "DD.MM.YYYY". Return val
       ues: TRUE, FALSE, E_REC_NR, E_HANDLE, E_FLD_TYPE, E_ALLOC.
       dbChangeRaw() doesn't work until now.

!node  dbDelRecord()
       int dbDelRecord (int handle, DWORD record_number);

       Delete  a  record  in the xbase file. The record is marked
       with a '*' at the beginning. While not using  dbPack()  or
       overwriting  the	record	you can restore it with dbUndelRecord().
       On success it returns TRUE.

!node dbUndelRecord()
      int dbUndelRecord (int handle, DWORD record_number);

       Undelete a record in the xbase file. The record is  marked
       with a ' ' (space). On success it returns TRUE.

!node  dbGetMode()
       int dbGetMode (int handle);

       Returns	the  access  mode of the file: DB_READ, DB_WRITE,
       DB_IGNORE_MEMO, DB_IGNORE_MDX, DB_IGNORE_DEL.

!node  dbGetType()
       int dbGetType (int handle);

       Returns the type of table: 0x03, ..

!node  dbLastUpdate()
       char *dbLastUpdate(int handle);

       Gives a string which contains the  date	of  last  update.

       Pointer must be freed.

!node  dbCurrent()
       DWORD dbCurrent (int handle);

       Returns the current position of the internal pointer.

!node  dbPack()
       int dbPack (int handle);

       Packs  a	xbase	file.  It meens all undeleted records are
       moved to the beginning of the file and  the  EOF	mark  is
       moved  after the last not deleted record. The file size is
       not changed but the number of records  in  the  header  is
       down  counted to the number of not deleted records.  After
       using this funktion you can not undelete a deleted record.

!node  dbRestore()
       int dbRestore (int handle);

       In short hands it is an undo of dbPack(). It moves the EOF
       mark in the xbase file to the physical end of the file and
       increases accordingly the number of records in the header.
       This could result in double records!  Don't use it if  you
       don't know about what exactly happens!

!node  dbCopyToFile()
       int  dbCopyToFile (int handle, WORD *flds, WORD num, const
       char *path);

       Copies named fields to a new xbase file.	The  fields  are
       named  by  theire  number  and must be stored in flds.  To
       give the function the information how much  field  numbers
       are stored in flds use num.  If num is '0' all fields will
       be copied and flds will be  ignored.   path  contains  the
       file name of the new xbase file.

!node  dbIsDeleted()
       int dbIsDeleted (int handle, DWORD record_number);

       Checks if a record is deleted. Use the macro 'CURRENT' for
       record_number, to check the current record.  The	function
       returns	TRUE  if the specified record is deleted or FALSE
       if not.

!node  dbEof()
       int dbEof (int handle);

       Returns TRUE if the pointer is behind the last record else
       FALSE  also  if	there was an error (dberrno is set to the
       error value).


!node RETURN VALUES
       All return values are negative values. Don't forget to use
       signed variables to handle these return codes.

!label E_HANDLE
       E_HANDLE

       Wrong  handle  specified.  Use  onle the handles which are
       returned by dbOpen() or dbCreate().

!label E_REC_NR
       E_REC_NR

       Wrong record number, the specified record does not  exist.

!label E_FLD_NR
       E_FLD_NR

       Wrong  field number, the specified field does not exist or
       you give a number of fields = 0 to dbCreate().

!label E_FLD_TYPE
       E_FLD_TYPE

       Wrong field type, the specified field type is not ok.

!label E_IO
       E_IO

       I/O error while accessing a xbase  file,	e.g.  'file  not
       found', 'permission denied', etc..

!label E_ALLOC
       E_ALLOC

       Memory  allocation  error,  there is too less memory for a
       malloc() or alloc() call.

!label E_VERSION
       E_VERSION

       Wrong xbase file version.

!label E_WRONG_MODE
       E_WRONG_MODE

       A function tried to make a write access to  a  file  while
       this was oppend in read-mode.

!label E_HEADER
       E_HEADER

       An error in the header of the xbase file was found.

!label E_UNKNOWN
       E_UNKNOWN

       An unknown error :)


!node EXAMPLE
       /*
	* mini demo for the libdbf.a, converts a dbf to an ascii flat file
	* rasca, berlin 1996
	*/

       #include <stdlib.h> /* free() */
       #include <stdio.h>  /* cause of dbf.h and printf() */
       #include "dbf.h"	/* dbOpen(), dbStrNext(), dbClose() */

       int main (int argc, char **argv) {
	    int db;
	    char *s;

	    if (argc > 1) {
		 if ((db = dbOpen (argv[1], DB_READ)) > 0) {
		      while ((s = dbTrStrNext(db, ';')) != NULL) {
			   printf ("%s\n", s);
			   free (s);
		      }
		      dbClose (db);
		 }

	    }
	    return (0);
       }


!node AUTHOR
   Rasca Gmelch

	 InterNet: rasca@mozart.komm.hdk-berlin.de

	 World WW: http://home.pages.de/~rasca/

	 linuxNet: rasca@lupo.cib.linuxnet.org

	 Fido-Net: Rasca Gmelch, 2:2410/305.4

!end_document
