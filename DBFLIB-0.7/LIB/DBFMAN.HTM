<HTML><BODY><PRE>dbf(3)                Manual for Version 0.5               dbf(3)</PRE><H2>NAME</H2><PRE>       libdbf.a - simple routines for accessing xbase data files</PRE><H2>SYNOPSIS</H2><PRE>       <STRONG>#include</STRONG> <STRONG>&lt;stdio.h&gt;</STRONG>       <STRONG>#include</STRONG> <STRONG>&lt;dbf.h&gt;</STRONG>       <STRONG>int</STRONG> <STRONG>dbOpen</STRONG> <STRONG>(char</STRONG> <STRONG>*</STRONG><EM>path</EM><STRONG>,</STRONG> <STRONG>int</STRONG> <EM>mode)</EM<STRONG>);</STRONG>       <STRONG>int</STRONG> <STRONG>dbCreate</STRONG> <STRONG>(const</STRONG> <STRONG>char</STRONG> <STRONG>*</STRONG><EM>path</EM><STRONG>,</STRONG> <STRONG>WORD</STRONG> <EM>nof</EM><STRONG>,</STRONG> <STRONG>UCHAR</STRONG> <EM>type)</EM<STRONG>);</STRONG>       <STRONG>int</STRONG> <STRONG>dbClose</STRONG> <STRONG>(int</STRONG> <EM>handle)</EM<STRONG>);</STRONG>       <STRONG>int</STRONG>  <STRONG>dbInitField</STRONG> <STRONG>(int</STRONG> <EM>handle</EM><STRONG>,</STRONG> <STRONG>WORD</STRONG> <EM>fnr</EM><STRONG>,</STRONG> <STRONG>UCHAR</STRONG> <STRONG>*</STRONG><EM>name</EM><STRONG>,</STRONG> <STRONG>UCHAR</STRONG>       <EM>type</EM><STRONG>,</STRONG> <STRONG>UCHAR</STRONG> <EM>length</EM><STRONG>,</STRONG> <STRONG>UCHAR</STRONG> <EM>dec)</EM<STRONG>);</STRONG>       <STRONG>int</STRONG> <STRONG>dbGotoNr</STRONG> <STRONG>(int</STRONG> <EM>handle</EM><STRONG>,</STRONG> <STRONG>DWORD</STRONG> <EM>num)</EM<STRONG>);</STRONG>       <STRONG>int</STRONG> <STRONG>dbWind</STRONG> <STRONG>(int</STRONG> <EM>handle</EM><STRONG>,</STRONG> <STRONG>long</STRONG> <STRONG>int</STRONG> <EM>offset)</EM<STRONG>);</STRONG>       <STRONG>DWORD</STRONG> <STRONG>dbGetNumOfRecs</STRONG> <STRONG>(int</STRONG> <EM>handle)</EM<STRONG>);</STRONG>       <STRONG>int</STRONG> <STRONG>dbGetNumOfFields</STRONG> <STRONG>(int</STRONG> <EM>handle)</EM<STRONG>);</STRONG>       <STRONG>int</STRONG> <STRONG>dbGetFieldLength</STRONG> <STRONG>(int</STRONG> <EM>handle</EM><STRONG>,</STRONG> <STRONG>WORD</STRONG> <EM>num)</EM<STRONG>);</STRONG>       <STRONG>int</STRONG> <STRONG>dbGetFieldNum</STRONG> <STRONG>(int</STRONG> <EM>handle</EM><STRONG>,</STRONG> <STRONG>const</STRONG> <STRONG>char</STRONG> <STRONG>*</STRONG><EM>name)</EM<STRONG>);</STRONG>       <STRONG>char</STRONG> <STRONG>dbGetFieldType</STRONG> <STRONG>(int</STRONG> <EM>handle</EM><STRONG>,</STRONG> <STRONG>WORD</STRONG> <EM>num)</EM<STRONG>);</STRONG>       <STRONG>const</STRONG> <STRONG>UCHAR</STRONG> <STRONG>*dbGetFieldName</STRONG> <STRONG>(int</STRONG> <EM>handle</EM><STRONG>,</STRONG> <STRONG>WORD</STRONG> <EM>num)</EM<STRONG>);</STRONG>       <STRONG>UCHAR</STRONG> <STRONG>*dbGetExFieldName</STRONG> <STRONG>(int</STRONG> <EM>handle</EM><STRONG>,</STRONG> <STRONG>WORD</STRONG> <EM>num)</EM<STRONG>);</STRONG>       <STRONG>UCHAR</STRONG> <STRONG>*dbRawNext</STRONG> <STRONG>(int</STRONG> <EM>handle</EM><STRONG>,</STRONG> <STRONG>WORD</STRONG> <STRONG>*</STRONG><EM>num)</EM<STRONG>);</STRONG>       <STRONG>UCHAR</STRONG> <STRONG>*dbTrStrNext</STRONG> <STRONG>(int</STRONG> <EM>handle</EM><STRONG>,</STRONG> <STRONG>char</STRONG> <EM>seperator)</EM<STRONG>);</STRONG>       <STRONG>UCHAR</STRONG> <STRONG>*dbStrNext</STRONG> <STRONG>(int</STRONG> <EM>handle</EM><STRONG>,</STRONG> <STRONG>char</STRONG> <EM>seperator)</EM<STRONG>);</STRONG>       <STRONG>UCHAR</STRONG> <STRONG>*dbSelByNumber</STRONG> <STRONG>(int</STRONG> <EM>handle</EM><STRONG>,</STRONG> <STRONG>WORD</STRONG> <EM>num</EM><STRONG>,</STRONG> <STRONG>int</STRONG> <EM>go)</EM<STRONG>);</STRONG>       <STRONG>UCHAR</STRONG> <STRONG>*dbTrSelByNumber</STRONG> <STRONG>(int</STRONG> <EM>handle</EM><STRONG>,</STRONG> <STRONG>WORD</STRONG> <EM>num</EM><STRONG>,</STRONG> <STRONG>int</STRONG> <EM>go)</EM<STRONG>);</STRONG>       <STRONG>UCHAR</STRONG> <STRONG>*dbTrSelByName</STRONG> <STRONG>(int</STRONG> <EM>handle</EM><STRONG>,</STRONG>  <STRONG>const</STRONG>  <STRONG>char</STRONG>  <STRONG>*</STRONG><EM>fld</EM><STRONG>,</STRONG>  <STRONG>int</STRONG>       <EM>go)</EM<STRONG>);</STRONG>       <STRONG>int</STRONG> <STRONG>dbSetShowDel</STRONG> <STRONG>(int</STRONG> <EM>handle</EM><STRONG>,</STRONG> <STRONG>int</STRONG> <EM>mode)</EM<STRONG>);</STRONG>       <STRONG>int</STRONG> <STRONG>dbSetUseMemo</STRONG> <STRONG>(int</STRONG> <EM>handle</EM><STRONG>,</STRONG> <STRONG>int</STRONG> <EM>mode)</EM<STRONG>);</STRONG>       <STRONG>int</STRONG>  <STRONG>dbChangeField</STRONG>  <STRONG>(int</STRONG>  <EM>handle</EM><STRONG>,</STRONG> <STRONG>DWORD</STRONG> <EM>rn</EM><STRONG>,</STRONG> <STRONG>WORD</STRONG> <EM>fn</EM><STRONG>,</STRONG> <STRONG>const</STRONG>       <STRONG>char</STRONG> <STRONG>*s);</STRONG>       <STRONG>int</STRONG> <STRONG>dbChangeFieldRaw</STRONG> <STRONG>(int</STRONG> <EM>handle</EM><STRONG>,</STRONG>  <STRONG>DWORD</STRONG>  <EM>rnr</EM><STRONG>,</STRONG>  <STRONG>WORD</STRONG>  <EM>fnr</EM><STRONG>,</STRONG>       <STRONG>const</STRONG> <STRONG>void</STRONG> <STRONG>*</STRONG><EM>data)</EM<STRONG>);</STRONG>       <STRONG>int</STRONG> <STRONG>dbDelRecord</STRONG> <STRONG>(int</STRONG> <EM>handle</EM><STRONG>,</STRONG> <STRONG>DWORD</STRONG> <EM>record</EM><STRONG>_</STRONG><EM>number)</EM<STRONG>);</STRONG>       <STRONG>int</STRONG> <STRONG>dbUndelRecord</STRONG> <STRONG>(int</STRONG> <EM>handle</EM><STRONG>,</STRONG> <STRONG>DWORD</STRONG> <EM>record</EM><STRONG>_</STRONG><EM>number)</EM<STRONG>);</STRONG>       <STRONG>int</STRONG> <STRONG>dbGetMode</STRONG> <STRONG>(int</STRONG> <EM>handle)</EM<STRONG>);</STRONG>       <STRONG>int</STRONG> <STRONG>dbGetType</STRONG> <STRONG>(int</STRONG> <EM>handle)</EM<STRONG>);</STRONG>       <STRONG>char</STRONG> <STRONG>*dbLastUpdate(int</STRONG> <EM>handle)</EM<STRONG>);</STRONG>       <STRONG>int</STRONG> <STRONG>dbPack</STRONG> <STRONG>(int</STRONG> <EM>handle)</EM<STRONG>);</STRONG>       <STRONG>int</STRONG> <STRONG>dbRestore</STRONG> <STRONG>(int</STRONG> <EM>handle)</EM<STRONG>);</STRONG>       <STRONG>int</STRONG>  <STRONG>dbCopyToFile</STRONG> <STRONG>(int</STRONG> <EM>handle</EM><STRONG>,</STRONG> <STRONG>WORD</STRONG> <EM>*flds</EM><STRONG>,</STRONG> <STRONG>WORD</STRONG> <EM>num</EM><STRONG>,</STRONG> <STRONG>const</STRONG>       <STRONG>char</STRONG> <EM>*path)</EM<STRONG>);</STRONG>       <STRONG>int</STRONG> <STRONG>dbIsDeleted</STRONG> <STRONG>(int</STRONG> <EM>handle</EM><STRONG>,</STRONG> <STRONG>DWORD</STRONG> <EM>record</EM><STRONG>_</STRONG><EM>number)</EM<STRONG>);</STRONG>       <STRONG>int</STRONG> <STRONG>dbEof</STRONG> <STRONG>(int</STRONG> <EM>handle)</EM<STRONG>);</STRONG>       <STRONG>DWORD</STRONG> <STRONG>dbAppendBlank</STRONG> <STRONG>(int</STRONG> <EM>handle)</EM<STRONG>);</STRONG>       <STRONG>DWORD</STRONG> <STRONG>dbCurrent</STRONG> <STRONG>(int</STRONG> <EM>handle)</EM<STRONG>);</STRONG>       This library is designed to  access  xBase  files  (dBase,dbf(3)                Manual for Version 0.5               dbf(3)       of errors and the concept of return codes! The source code       and  the  example  programs  are  published  under the GNU       Librabry General Public License and the GNU General Public       License.   To  extend  the  library  i need more technical       informations about the file formats. If you can  help  me,       please  email  ..  (see  the end of the man-page for email       addresses).       <STRONG>int</STRONG> <STRONG>dbOpen</STRONG> <STRONG>(char</STRONG> <STRONG>*</STRONG><EM>path</EM><STRONG>,</STRONG> <STRONG>int</STRONG> <EM>mode)</EM<STRONG>);</STRONG>       Opens the xbase-file <EM>path</EM> and returns an  integer  as  the       <EM>handle</EM>  for referencing this file due next operations. The       variable <EM>mode</EM> could be DB_READ, DB_WRITE,  DB_IGNORE_MEMO,       DB_IGNORE_MDX,  DB_IGNORE_DEL and DB_FOXPRO. If you choose       more then one argument they  must  be  ored.   DB_READ  is       obsolet  if you use DB_WRITE.  DB_WRITE with memo files is       not very well tested :(. Have a look at  the  end  of  the       man-page  for  the error codes. For an example how to call       the function see EXAMPLE in the man-page.       <STRONG>int</STRONG> <STRONG>dbCreate</STRONG> <STRONG>(const</STRONG> <STRONG>char</STRONG> <STRONG>*</STRONG><EM>path</EM><STRONG>,</STRONG> <STRONG>WORD</STRONG> <EM>nof</EM><STRONG>,</STRONG> <STRONG>UCHAR</STRONG> <EM>type)</EM<STRONG>);</STRONG>       Creates a new xbase file, <EM>nof</EM> is  the  number  of  fields.       <EM>type</EM>  must  be  DB_DBASE3,  DB_DBASE4  or DB_FOXPRO. After       calling dbCreate() you  have  to  call  dbInitField()  for       every  field in the new xbase file to specify type, length       etc.. The function returns the handle  of  the  new  xbase       file  on success or E_FLD_NR, E_IO, E_ALLOC or E_HANDLE on       failure.       <STRONG>int</STRONG> <STRONG>dbClose</STRONG> <STRONG>(int</STRONG> <EM>handle)</EM<STRONG>);</STRONG>       This function closes a xbase-file. It returns TRUE on suc­       cess or E_IO, E_HANDLE on failure. See below for the error       codes.       <STRONG>int</STRONG> <STRONG>dbInitField</STRONG> <STRONG>(int</STRONG> <EM>handle</EM><STRONG>,</STRONG> <STRONG>WORD</STRONG> <EM>fnr</EM><STRONG>,</STRONG> <STRONG>UCHAR</STRONG> <STRONG>*</STRONG><EM>name</EM><STRONG>,</STRONG>  <STRONG>UCHAR</STRONG>       <EM>type</EM><STRONG>,</STRONG> <STRONG>UCHAR</STRONG> <EM>length</EM><STRONG>,</STRONG> <STRONG>UCHAR</STRONG> <STRONG>dec);</STRONG>       Change  the  type  etc. of a new field. If the name of the       field is too long it is striped to 10 characters. Use this       function  immeditly  after  a  dbCreate() call. If you use       this function for a existing xbase file or after appending       the first record you will run into an error (return value:       FALSE)!  Valid  field  types   are:   FT_CHARS,   FT_DATE,       FT_FLOAT,   FT_BOOLEAN,   FT_MEMO,  FT_NUMBER,  FT_BINARY,       FT_GENERAL  and  FT_OBJECT.   FT_BINARY,  FT_GERNERAL  and       FT_OBJECT are not handled correct!.dbf(3)                Manual for Version 0.5               dbf(3)       <STRONG>int</STRONG> <STRONG>dbWind</STRONG> <STRONG>(int</STRONG> <EM>handle</EM><STRONG>,</STRONG> <STRONG>long</STRONG> <STRONG>int</STRONG> <EM>offset)</EM<STRONG>);</STRONG>       Goes  <EM>offset</EM> records backward or forward in the file which       belongs to <EM>handle</EM>.  dbWind  returns  TRUE  on  success  or       E_HANDLE, E_REC_NR or E_IO on error.       <STRONG>DWORD</STRONG> <STRONG>dbGetNumOfRecs</STRONG> <STRONG>(int</STRONG> <EM>handle)</EM<STRONG>);</STRONG>       Returns  the  number  of records in the table specified by       <EM>handle</EM>.  Deleted records  are  also  counted.  On  failure       <EM>dberrno</EM> is set to E_HANDLE and the return value is 0.       <STRONG>int</STRONG> <STRONG>dbGetNumOfFields</STRONG> <STRONG>(int</STRONG> <EM>handle)</EM<STRONG>);</STRONG>       Returns  the  number  of  fields of the file pointed to by       <EM>handle</EM>.  If <EM>handle</EM> has a wrong value it returns  E_HANDLE.       <STRONG>int</STRONG> <STRONG>dbGetFieldLength</STRONG> <STRONG>(int</STRONG> <EM>handle</EM><STRONG>,</STRONG> <STRONG>WORD</STRONG> <EM>num)</EM<STRONG>);</STRONG>       Returns  the  length  of  the  <EM>num</EM>-th  field.  It  returns       E_HANDLE if the <EM>handle</EM> is wrong and E_FLD_NR if <EM>num</EM> is not       ok.  If  the type of the field is FT_MEMO or FT_OBJECT not       the length of the memo entry is returned but the length of       the  field  in the xbase file where the memo record number       is stored. This is for memo and for object fields all  the       time '10'.       <STRONG>char</STRONG> <STRONG>dbGetFieldType</STRONG> <STRONG>(int</STRONG> <EM>handle</EM><STRONG>,</STRONG> <STRONG>WORD</STRONG> <EM>num)</EM<STRONG>);</STRONG>       Returns  the type of the field in <EM>handle</EM>.  Could be one of       FT_CHARS,   FT_DATE,   FT_FLOAT,   FT_BOOLEAN,    FT_MEMO,       FT_NUMBER, FT_BINARY, FT_OBJECT, FT_GENERAL or FT_UNKNOWN.       <STRONG>const</STRONG> <STRONG>UCHAR</STRONG> <STRONG>*dbGetFieldName</STRONG> <STRONG>(int</STRONG> <EM>handle</EM><STRONG>,</STRONG> <STRONG>WORD</STRONG> <EM>num)</EM<STRONG>);</STRONG>       Returns the name of the <EM>num</EM>-th field. The return value  is       NULL if some errors are occurred.       <STRONG>UCHAR</STRONG> <STRONG>*dbGetExFieldName</STRONG> <STRONG>(int</STRONG> <EM>handle</EM><STRONG>,</STRONG> <STRONG>WORD</STRONG> <EM>num)</EM<STRONG>);</STRONG>       returns the name of the field expaned to the lenght of the       field and padded with spaces. If the field width  is  less       than  the  length  of  the  field  name  the  width of the       returned string is expanded to 10. The function  is  desi­       gend for formated output.       <STRONG>UCHAR</STRONG> <STRONG>*dbRawNext</STRONG> <STRONG>(int</STRONG> <EM>handle</EM><STRONG>,</STRONG> <STRONG>WORD</STRONG> <STRONG>*</STRONG><EM>num)</EM<STRONG>);</STRONG>dbf(3)                Manual for Version 0.5               dbf(3)       <STRONG>UCHAR</STRONG> <STRONG>*dbTrStrNext</STRONG> <STRONG>(int</STRONG> <EM>handle</EM><STRONG>,</STRONG> <STRONG>char</STRONG> <EM>seperator)</EM<STRONG>);</STRONG>       Reads  the next record from <EM>handle</EM> and returns a converted       char line seperated by <EM>seperator</EM> incl. a closing '\0'.  At       the  end  of  the  file  a  NULL is returned.  If the next       record is a deleted record and dbSetShowDel()  is  set  to       FALSE a '\0' is returned (default: show deleted records!).       After using the pointer which is returned you  must  clean       it with <STRONG>free(3)</STRONG>.       <STRONG>UCHAR</STRONG> <STRONG>*dbStrNext</STRONG> <STRONG>(int</STRONG> <EM>handle</EM><STRONG>,</STRONG> <STRONG>char</STRONG> <EM>seperator)</EM<STRONG>);</STRONG>       Is the non-stripping version. It ignores memo-files, cause       the field length of memo-fields are not fixed!       <STRONG>UCHAR</STRONG> <STRONG>*dbSelByNumber</STRONG> <STRONG>(int</STRONG> <EM>handle</EM><STRONG>,</STRONG> <STRONG>WORD</STRONG> <EM>num</EM><STRONG>,</STRONG> <STRONG>int</STRONG> <EM>go)</EM<STRONG>);</STRONG>       Read the <EM>num-th</EM> field from the next record of <EM>handle</EM>.   If       <EM>go</EM>  is  FALSE  the function will not go to the next record       after reading.  After using the pointer which is  returned       you must clean it with <STRONG>free(3)</STRONG>.  The function returns NULL       if the record couldn't be read (e.g.  EOF),  '\0'  if  the       record is deleted or the field if all is ok.       <STRONG>UCHAR</STRONG> <STRONG>*dbTrSelByNumber</STRONG> <STRONG>(int</STRONG> <EM>handle</EM><STRONG>,</STRONG> <STRONG>WORD</STRONG> <EM>num</EM><STRONG>,</STRONG> <STRONG>int</STRONG> <EM>go)</EM<STRONG>);</STRONG>       Read  the <EM>num-th</EM> field from the next record of <EM>handle</EM>.  If       <EM>go</EM> is FALSE the function will not go to  the  next  record       after  reading.  After using the pointer which is returned       you must clean it with <STRONG>free(3)</STRONG>.  White spaces are trimmed.       Date fields are converted to DD-MM-YYYY.       <STRONG>UCHAR</STRONG>  <STRONG>*dbTrSelByName</STRONG>  <STRONG>(int</STRONG> <EM>handle</EM><STRONG>,</STRONG> <STRONG>const</STRONG> <STRONG>char*</STRONG> <EM>field</EM><STRONG>,</STRONG> <STRONG>int</STRONG>       <EM>go)</EM<STRONG>);</STRONG>       Read the field <EM>field</EM> from the next record of  <EM>handle</EM>.   If       <EM>go</EM>  is  FALSE  the function will not go to the next record       after reading.  After using the pointer which is  returned       you must clean it with <STRONG>free(3)</STRONG>.  White spaces are trimmed.       Date fields are converted to DD-MM-YYYY.       <STRONG>int</STRONG> <STRONG>dbSetShowDel</STRONG> <STRONG>(int</STRONG> <EM>handle</EM><STRONG>,</STRONG> <STRONG>int</STRONG> <EM>mode)</EM<STRONG>);</STRONG>       Sets whether deleted  records  should  be  shown  or  not,       default  is  TRUE.   Normaly  you set this while opening a       xbase   file   and   give   the   correct    mode,    e.g.       dbOpen("foo.dbf",  DB_READ  |  DB_IGNORE_DEL). But you can       also use this function  to  switch  at  runtime.  Possible       arguments are TRUE and FALSE.dbf(3)                Manual for Version 0.5               dbf(3)       E_HANDLE, E_WRONG_MODE or to E_ALLOC.  On success the num­       ber of the new record is returned.       <STRONG>int</STRONG> <STRONG>dbChangeField</STRONG> <STRONG>(int</STRONG> <EM>handle</EM><STRONG>,</STRONG> <STRONG>DWORD</STRONG> <EM>rnr</EM><STRONG>,</STRONG> <STRONG>WORD</STRONG>  <EM>fnr</EM><STRONG>,</STRONG>  <STRONG>char</STRONG>       <STRONG>*</STRONG><EM>data)</EM<STRONG>);</STRONG>       Change  the  content  of  a  field. data is a pointer to a       string which contains the new information  of  the  field.       dbChangeField()  converts  this to the corresponding field       type.  <EM>rnr</EM> is the record number and <EM>fnr</EM> is the field  num­       ber  which  should be changed. For date fields <EM>data</EM> should       be a string like "DD-MM-YYYY" or "DD.MM.YYYY". Return val­       ues: TRUE, FALSE, E_REC_NR, E_HANDLE, E_FLD_TYPE, E_ALLOC.       dbChangeRaw() doesn't work until now.       <STRONG>int</STRONG> <STRONG>dbDelRecord</STRONG> <STRONG>(int</STRONG> <EM>handle</EM><STRONG>,</STRONG> <STRONG>DWORD</STRONG> <EM>record</EM><STRONG>_</STRONG><EM>number)</EM<STRONG>);</STRONG>       Delete a record in the xbase file. The  record  is  marked       with  a  '*' at the beginning. While not using dbPack() or       overwriting the record you can restore  it  with  dbUndel­       Record(). On success it returns TRUE.       <STRONG>int</STRONG> <STRONG>dbUndelRecord</STRONG> <STRONG>(int</STRONG> <EM>handle</EM><STRONG>,</STRONG> <STRONG>DWORD</STRONG> <EM>record</EM><STRONG>_</STRONG><EM>number)</EM<STRONG>);</STRONG>       Undelete  a record in the xbase file. The record is marked       with a ' ' (space). On success it returns TRUE.       <STRONG>int</STRONG> <STRONG>dbGetMode</STRONG> <STRONG>(int</STRONG> <EM>handle)</EM<STRONG>);</STRONG>       Returns the access mode of the  file:  DB_READ,  DB_WRITE,       DB_IGNORE_MEMO, DB_IGNORE_MDX, DB_IGNORE_DEL.       <STRONG>int</STRONG> <STRONG>dbGetType</STRONG> <STRONG>(int</STRONG> <EM>handle)</EM<STRONG>);</STRONG>       Returns the type of table: 0x03, ..       <STRONG>char</STRONG> <STRONG>*dbLastUpdate(int</STRONG> <EM>handle)</EM<STRONG>);</STRONG>       Gives  a  string  which  contains the date of last update.       Pointer must be freed.       <STRONG>int</STRONG> <STRONG>dbPack</STRONG> <STRONG>(int</STRONG> <EM>handle)</EM<STRONG>);</STRONG>       Packs a xbase file. It meens  all  undeleted  records  are       moved  to  the  beginning  of the file and the EOF mark is       moved after the last not deleted record. The file size  is       not  changed  but  the  number of records in the header is       down counted to the number of not deleted records.   After       using this funktion you can not undelete a deleted record.dbf(3)                Manual for Version 0.5               dbf(3)       increases accordingly the number of records in the header.       This  could result in double records!  Don't use it if you       don't know about what exactly happens!       <STRONG>int</STRONG> <STRONG>dbCopyToFile</STRONG> <STRONG>(int</STRONG> <EM>handle</EM><STRONG>,</STRONG> <STRONG>WORD</STRONG> <EM>*flds</EM><STRONG>,</STRONG> <STRONG>WORD</STRONG> <EM>num</EM><STRONG>,</STRONG>  <STRONG>const</STRONG>       <STRONG>char</STRONG> <EM>*path)</EM<STRONG>);</STRONG>       Copies  named  fields  to a new xbase file. The fields are       named by theire number and must be  stored  in  <EM>flds</EM>.   To       give  the  function the information how much field numbers       are stored in <EM>flds</EM> use <EM>num</EM>.  If <EM>num</EM> is '0' all fields will       be  copied  and  <EM>flds</EM>  will be ignored.  <EM>path</EM> contains the       file name of the new xbase file.       <STRONG>int</STRONG> <STRONG>dbIsDeleted</STRONG> <STRONG>(int</STRONG> <EM>handle</EM><STRONG>,</STRONG> <STRONG>DWORD</STRONG> <EM>record</EM><STRONG>_</STRONG><EM>number)</EM<STRONG>);</STRONG>       Checks if a record is deleted. Use the macro 'CURRENT' for       <EM>record</EM><STRONG>_</STRONG><EM>number</EM>,  to  check the current record. The function       returns TRUE if the specified record is deleted  or  FALSE       if not.       <STRONG>int</STRONG> <STRONG>dbEof</STRONG> <STRONG>(int</STRONG> <EM>handle)</EM<STRONG>);</STRONG>       Returns TRUE if the pointer is behind the last record else       FALSE also if there was an error (dberrno is  set  to  the       error value).</PRE><H2>RETURN VALUES</H2><PRE>       All return values are negative values. Don't forget to use       signed variables to handle these return codes.       <STRONG>E_HANDLE</STRONG>       Wrong handle specified. Use onle  the  handles  which  are       returned by dbOpen() or dbCreate().       <STRONG>E_REC_NR</STRONG>       Wrong  record number, the specified record does not exist.       <STRONG>E_FLD_NR</STRONG>       Wrong field number, the specified field does not exist  or       you give a number of fields = 0 to dbCreate().       <STRONG>E_FLD_TYPE</STRONG>       Wrong field type, the specified field type is not ok.       <STRONG>E_IO</STRONG>       I/O  error  while  accessing  a xbase file, e.g. 'file not       found', 'permission denied', etc..dbf(3)                Manual for Version 0.5               dbf(3)       <STRONG>E_VERSION</STRONG>       Wrong xbase file version.       <STRONG>E_WRONG_MODE</STRONG>       A  function  tried  to make a write access to a file while       this was oppend in read-mode.       <STRONG>E_HEADER</STRONG>       An error in the header of the xbase file was found.       <STRONG>E_UNKNOWN</STRONG>       An unknown error :)</PRE><H2>EXAMPLE</H2><PRE>       /*        * mini demo for the libdbf.a, converts a dbf to an ascii flat file        * rasca, berlin 1996        */       #include &lt;stdlib.h&gt; /* free() */       #include &lt;stdio.h&gt;  /* cause of dbf.h and printf() */       #include "dbf.h"    /* dbOpen(), dbStrNext(), dbClose() */       int main (int argc, char **argv) {            int db;            char *s;            if (argc &gt; 1) {                 if ((db = dbOpen (argv[1], DB_READ)) &gt; 0) {                      while ((s = dbTrStrNext(db, ';')) != NULL) {                           printf ("%s\n", s);                           free (s);                      }                      dbClose (db);                 }            }            return (0);       }</PRE><H2>BUGS</H2><PRE>       <STRONG>libdbf</STRONG> has 10^12 * 3.1415 bugs or more :-)</PRE><H2>TODO</H2><PRE>       functions for modifying and creating index  files,  better       man-pages   :)   etc..   Support  for  decimal  point  for       FT_NUMBER.dbf(3)                Manual for Version 0.5               dbf(3)         World WW: http://home.pages.de/~rasca/         linuxNet: rasca@lupo.cib.linuxnet.org         Fido-Net: Rasca Gmelch, 2:2410/305.4</PRE></BODY></HTML>