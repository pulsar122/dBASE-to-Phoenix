/* * This file contains some routines for handling xBase files. It is * pubilshed under the GNU Library Gerneral Public License (GPL), * see COPYING.lib for details. * * WARNING: This is ALPHA code!!! *          Writing xbase files is NOT full supported until now!!! *          Index files are also not supported :( * * (c) rasca, berlin 1994, 1995, 1996, 1997 * (rasca@mozart.komm.hdk-berlin.de) * * vi: set tabstop=4 */#include <stdlib.h>     /* malloc(), calloc(), free(), realloc() */#include <string.h>     /* strlen () */#include <ctype.h>      /* toupper() */#include <time.h>       /* time() */#include <ext.h>				/* stat() */
#define	S_IFMT			0170000				/* fÅr stat()	*/#define	S_IFCHR			0020000#define	S_IFDIR			0040000#define S_IFBLK			0060000#define	S_IFREG			0100000#define S_IFIFO			0120000#define S_IMEM			0140000#define	S_IFLNK			0160000

#if defined (linux) || defined (unix)#include <unistd.h>		/* stat() */#endif#ifdef WINDLL#include <windows.h>	/* needed for the DLL support */#define perror(x)	onerror(x)void onerror (const char *);#endif#include "dbf.h"        /* exported xbase routines and types etc.. */#ifndef min#define min(a,b) ((a) < (b) ? (a) : (b))#define max(a,b) ((a) > (b) ? (a) : (b))#endifint dberrno = 0;/* */DWORD Swap4Bytes (DWORD dw) {	DWORD tmp;	tmp =  (dw & 0x000000FF);	tmp = ((dw & 0x0000FF00) >> 0x08) | (tmp << 0x08);	tmp = ((dw & 0x00FF0000L) >> 0x10) | (tmp << 0x08);	tmp = ((dw & 0xFF000000L) >> 0x18) | (tmp << 0x08);	return (tmp);}/* */WORD Swap2Bytes (WORD w) {	WORD tmp;	tmp =  (w & 0x00FF);	tmp = ((w & 0xFF00) >> 0x08) | (tmp << 0x08);	return (tmp);}/* for little/big endian support, see also dbf.h! */#ifdef LSB_HOST	#define fread2bytes(x, fp) fread(x, sizeof(WORD), 1, fp)	#define fread4bytes(x, fp) fread(x, sizeof(DWORD), 1, fp)#else	/* MSB_HOST */static int fread2bytes (WORD *x, FILE *fp) {	long rc;	rc = fread(x, sizeof(WORD), 1, fp);	*x = Swap2Bytes (*x);	return ( (int) rc );}static int fread4bytes (DWORD *x, FILE *fp) {	long rc;	rc = fread(x, sizeof(DWORD), 1, fp);	*x = Swap4Bytes (*x);	return ( (int) rc );}#endif#ifdef LSB_HOST	#define fwrite2bytes(x, fp) fwrite(x, sizeof(WORD), 1, fp)	#define fwrite4bytes(x, fp) fwrite(x, sizeof(DWORD), 1, fp)#elsestatic int fwrite2bytes (WORD *x, FILE *fp) {	WORD w;	w = Swap2Bytes (*x);	return ( (int) fwrite (&w, sizeof(WORD), 1, fp));}static int fwrite4bytes (DWORD *x, FILE *fp) {	DWORD dw;	dw = Swap4Bytes (*x);	return ( (int) fwrite (&dw, sizeof(DWORD), 1, fp));}#endif/* * allocates RAM for every node entry in the list of open xBase-files */static DBF *alloc_dbf (WORD num_of_fields)
{	DBF *db;	WORD i;	db = (DBF *) malloc (sizeof (DBF));	if (db != NULL)
	{		db->offset = (WORD *) malloc (num_of_fields * sizeof(*db->offset));		db->current = 1;		db->idx = NULL;		db->head = (db_header *) malloc (sizeof(db_header));
		db->fields = (db_field **) malloc (sizeof(db_field*) * num_of_fields);		if ((db->head != NULL) && (db->fields != NULL)) {			/*			 * alloc RAM for every pointer			 */			for (i = 0; i < num_of_fields; i++) {				db->fields[i] = (db_field *) calloc (sizeof(db_field), sizeof(UCHAR));				if (db->fields[i] == NULL) {					/* clean up the stuff we have allocated until now */					while (i > 0)						free (db->fields[--i]);					free (db->head); free (db->fields); free (db);					perror ("alloc_dbf()");					return (NULL);				} else {					db->fields[i]->type = FT_UNKNOWN;				}			}			/*			 * some default values */			db->fp = NULL;			db->num_of_fields = num_of_fields;			db->access_mode = DB_READ;			db->memo = NULL;			return (db);		}		free (db->head);		free (db->fields);		free (db);	}	perror ("alloc_dbf()");	return (NULL);}/* * alloc memory for a memo field structure */static db_memo *alloc_memo (char *fname, int type) {	db_memo *p;	size_t len;	char *hpt;	WORD i;	p = (db_memo *) malloc (sizeof (db_memo));	if (!p) {		perror ("alloc_memo()");		return (NULL);	}	p->next_free =  8;	for (i = 0; i < sizeof(p->fill); i++)		p->fill[i] = 0;	p->fp = NULL;	p->type = type;	len = strlen (fname);	memcpy (p->file_name, fname, len +1);	hpt = p->file_name;	while (*hpt)		hpt++;	hpt -= 3;	switch (type) {	case MEMO_DBASE:		memcpy (hpt, "dbt", 3);		p->block_size = 512;		break;	case MEMO_FOXPRO:		memcpy (hpt, "fpt", 3);		p->block_size = 64;		break;	default:		break;	}	return (p);}/* */static void free_memo (db_memo *mpt) {	free (mpt);}/* * free a dbf pointer, needed from rm_dbf_from_list() and dbOpen() */static int free_dbf (DBF *db) {	if ((db != NULL) && (db->fields != NULL)) {		while (db->num_of_fields > 0) {			free (db->fields[db->num_of_fields-1]);			db->num_of_fields--;		}		if (db->memo != NULL) {			free_memo (db->memo);		}		free (db->offset);		free (db->idx);		free (db->fields);		free (db->head);		free (db);		return (TRUE);	} else {		return (FALSE);	}}/* * needed for the list of open xBase files */static int last_index=	0;static int next_free =	0;static DBF *dbf[MAX_FILES+1];/* * returns a pointer to the structure of the * database which belongs to the handle 'x' */#define num2db(x) ((x > 0 && x <= last_index) ? dbf[x] : NULL)/* * add a new DBF structure to the list of * open xBase files */static int add_dbf_to_list (DBF *new) {	int new_handle;	last_index++;	if (last_index == MAX_FILES+1) {		last_index--;		/* we ran out of space for the index value :(		 * look for the next free handle		 */		if (next_free != 0) {			new_handle = next_free;			next_free = 0;		} else {			/* this should never be reached, if there are less			   than MAX_FILES files are open at once .. */			return (0);		}	} else {		new_handle = last_index;		if (new_handle == next_free) {			next_free = 0;		}	}	new->handle = new_handle;	dbf[new_handle] = new;	return (new_handle);}/* * remove an entry from the list of open * data bases */static int rm_dbf_from_list (DBF *db) {	if (db->handle == last_index) {		/* we could give the handle free		 */		last_index--;	} else {		next_free = db->handle;	}	dbf[db->handle] = NULL;	free_dbf (db);	return (TRUE);}/* * dump the header to stdout, usefull for debugging */static int dump_header (DBF *db) {	db_header *head;	UCHAR version, t;	int num_of_fdesc;	head = db->head;	version = head->type & XBASE_VERSION_MASK;	num_of_fdesc = (head->header_size - 32 - 1) /32;	t = head->type;	fprintf (stdout, "type              : %d\n", version);	fprintf (stdout, "first byte        : 0x%X (%d%d%d%d %d%d%d%d)\n",				t, bit(t,7), bit(t,6), bit(t,5), bit(t,4), bit(t,3),				bit(t,2), bit(t,1), bit(t,0));	fprintf (stdout, "memo              : %d (1=DBASE, 2=FOXPRO)\n", db->memoflag);	fprintf (stdout, "last modification : %02d:%02d:%02d\n",		head->lm_dd, head->lm_mm, head->lm_yy);	fprintf (stdout, "crypted           : %s\n", head->crypted ? "yes" : "no");	fprintf (stdout, "mdx/cdx file      : %s\n", head->mdx ? "yes" : "no");	fprintf (stdout, "number of entries : %ld\n", head->num_of_recs);	fprintf (stdout, "size of head total: %d ( = %d fields)\n",		head->header_size, num_of_fdesc);	fprintf (stdout, "size of a record  : %d bytes\n", head->record_size);	fprintf (stdout, "broken transaction: %s\n", head->transaction ? "yes" : "no");	fprintf (stdout, "code page flag    : 0x%02X (0x03 = Windows ANSI, 0x02 = Intern. MSDOS)\n", head->code);	return (TRUE);}/* * read the 32 byte header, the freadXbytes() functions are * for support of little and big endian machines .. */static void io_read_header (db_header *head, FILE *fp) {	fread (&(head->type), sizeof (UCHAR), 1, fp);	fread (&(head->lm_yy), sizeof (UCHAR), 1, fp);	fread (&(head->lm_mm), sizeof (UCHAR), 1, fp);	fread (&(head->lm_dd), sizeof (UCHAR), 1, fp);	fread4bytes (&(head->num_of_recs), fp);	fread2bytes (&(head->header_size), fp);	fread2bytes (&(head->record_size), fp);	fread (&(head->reserved1), sizeof(head->reserved1), 1, fp);	fread (&(head->transaction), sizeof(UCHAR), 1, fp);	fread (&(head->crypted), sizeof(UCHAR), 1, fp);	fread (&(head->net), sizeof(head->net), 1, fp);	fread (&(head->mdx), sizeof(UCHAR), 1, fp);	fread (&(head->code), sizeof(UCHAR), 1, fp);	fread (&(head->reserved2), sizeof(head->reserved2), 1, fp);}/* * read a field description from the header */static void io_read_field_desc (db_field *field_desc, FILE *fp) {	fread (&(field_desc->name), sizeof (field_desc->name), 1, fp);	fread (&(field_desc->type), sizeof (field_desc->type), 1, fp);	fread (&(field_desc->offset), sizeof (field_desc->offset), 1, fp);	fread (&(field_desc->reserved1), sizeof (field_desc->reserved1), 1, fp);	fread (&(field_desc->length), sizeof (field_desc->length), 1, fp);	fread (&(field_desc->dec_num), sizeof (field_desc->dec_num), 1, fp);	fread (&(field_desc->reserved2), sizeof (field_desc->reserved2), 1, fp);	fread (&(field_desc->work_id), sizeof (field_desc->work_id), 1, fp);	fread (&(field_desc->reserved3), sizeof (field_desc->reserved3), 1, fp);	fread (&(field_desc->set_fields), sizeof (field_desc->set_fields), 1, fp);	fread (&(field_desc->reserved4), sizeof (field_desc->reserved4), 1, fp);	fread (&(field_desc->mdx_tag), sizeof (field_desc->mdx_tag), 1, fp);}/* * read the header from a memo file */static int io_read_memo_header (db_memo *mptr) {		fread (&(mptr->next_free), sizeof (mptr->next_free), 1, mptr->fp);	fread (&(mptr->block_size), sizeof (mptr->block_size), 1, mptr->fp);	#ifdef LSB_HOST	mptr->block_size = Swap4Bytes (mptr->block_size);	mptr->next_free = Swap4Bytes (mptr->next_free);	#endif	if (ferror(mptr->fp) != 0) {		perror (mptr->file_name);		clearerr (mptr->fp);		return (FALSE);	} else {		return (TRUE);	}}/* * open and check a named dbf file .. * writing should work in some cases :) */int FAR EXPORT dbOpen (char *fname, int mode) {	FILE *fp;	DBF  *db;	db_header head;	db_field field_desc;	WORD i;	UCHAR EO_fdesc = 0;	UCHAR version;	UCHAR memo;	const char *fmode;	struct stat finfo;	int rc;	if (mode & DB_WRITE) {		fmode = "rb+";	} else {		fmode = "rb";	}	if ((stat (fname, &finfo)) == 0) {#if defined (linux) || defined (unix) /* is that posix? */		if (S_ISLNK(finfo.st_mode) || S_ISREG(finfo.st_mode)) {#else	/* DOS */		if ((finfo.st_mode & S_IFREG) || (finfo.st_mode == 0x0)) {#endif			if (finfo.st_size < 32 * 2 +1) {				/* file is too small, couldn't be a xbase file! */				return (E_HEADER);			}		} else {			/* it's not a regular file! */			return (E_IO);		}	} else {		perror (fname);		return (E_IO);	}	if ((fp = fopen (fname, fmode)) != NULL) {		/* read the header of the table ..		 */		io_read_header(&head, fp);		if (ferror (fp)) {			clearerr (fp);			fclose (fp);			return (E_IO);		}		if ((head.header_size < 32 + 32 + 1) || (feof(fp))) {			/* must be at least 65 to be a xbase file with one field			 * if header_size is < 65 perhaps it's not a xbase file..			 */			fclose (fp);			return (E_HEADER);		}		/* head.type (is it correct?):		  0x03 (0000 0011): dbase III+, IV, FoxBase, Foxpro 2.x		  0x83 (1000 0011): dbase III+, Foxbase  with memo-file		  0x8B (1000 1011): dbase IV with memo-file		  0x43 (0100 0011): ??		  0xF5 (1111 0101): Foxpro with memo-file		*/		version = head.type & XBASE_VERSION_MASK;		switch (version) {			case 0x03:				/* i am not shure if this is right :)				 */				if ((head.type & XBASE_MEMO_MASK) > 0)					memo = MEMO_DBASE;				else					memo = FALSE;				break;			case 0x05:				/* foxpro with memo				 */				if ((head.type & 0xF0) != 0xF0) {					fprintf (stderr, "Error: wrong xbase file version: 0x%X??\n", head.type);					return (E_VERSION);				}				memo = MEMO_FOXPRO;				break;			default:				fprintf (stderr, "Error: wrong xbase file version: 0x%x??\n", version);				return (E_VERSION);		}		/*		 * ok, now alloc a structure for a new entry in the list		 */		db = alloc_dbf ((WORD) ((head.header_size - 32 - 1) / 32));		if (db == NULL) {			fprintf (stderr, "dbOpen(): failed when calling alloc_db()\n");			return (E_ALLOC);		}		strncpy (db->file_name, fname, strlen(fname)+1);		db->fp = fp;		memcpy (db->head, &head, sizeof (db_header));		db->memoflag = memo;		db->access_mode = mode;		/* first check again the size of the file before		 * reading the rest of the header		 */		if (finfo.st_size < (signed long) (32 + (32 * db->num_of_fields) + 1)) {			fclose (fp);			free_dbf (db);			return (E_HEADER);		}		db->offset[0] = 1;		for (i = 0; i < db->num_of_fields; i++) {			io_read_field_desc (&field_desc, fp);			if (feof (fp) || ferror(fp)) {				clearerr (fp);				fclose (fp);				free_dbf (db);				return (E_IO);			}			field_desc.type = (UCHAR) toupper (field_desc.type);			memcpy (db->fields[i], &field_desc, sizeof (db_field));			if (i > 0)				db->offset[i] = db->offset[i-1] + db->fields[i-1]->length;#ifdef DEBUG2			fprintf (stderr, "%03d: %-8s\t(type: %c, length: %d) offset = %d\n",				i, field_desc.name, field_desc.type, field_desc.length, db->offset[i]);#endif		}		fread (&EO_fdesc, sizeof(EO_fdesc), 1, fp);		if (EO_fdesc != EO_FDESC) {			fprintf (stderr, "Fatal error in header: wanted 0x0D, found: 0x%X\n", EO_fdesc);			fclose (fp);			free_dbf (db);			return (E_HEADER);		}		if (db->head->transaction > 0)			fprintf (stderr, "Warning: file with broken transaction flag!\n");		if (mode & DB_WRITE)			db->head->transaction = 1;		/* look for memo file		 */		if (mode & DB_IGNORE_MEMO) {			db->memoflag = FALSE;		}		if (db->memoflag != FALSE) {			db->memo = alloc_memo (fname, db->memoflag);			if ((db->memo->fp = fopen (db->memo->file_name, fmode)) != NULL) {				io_read_memo_header (db->memo);			} else {				fprintf (stderr, "Warning: can't open %s\n", db->memo->file_name);				perror (db->memo->file_name);				free_memo (db->memo);				db->memo = NULL;				db->memoflag = FALSE;			}		}		/* all worked fine, so add 'db' to the active list		 * and return the handle to the entry ..		 */		rc = add_dbf_to_list(db);		if (!rc) {			fclose(fp);			free_dbf(db);			return (E_HANDLE);		}		return (rc);	} else {		perror (fname);		return (E_IO);	}}/* * write a field header to the xbase file */static void io_write_field_desc (db_field *fdesc, FILE *fp) {	fwrite (&(fdesc->name), sizeof (fdesc->name), 1, fp);	fwrite (&(fdesc->type), sizeof (fdesc->type), 1, fp);	fwrite (&(fdesc->offset), sizeof (fdesc->offset), 1, fp);	fwrite (&(fdesc->reserved1), sizeof (fdesc->reserved1), 1, fp);	fwrite (&(fdesc->length), sizeof (fdesc->length), 1, fp);	fwrite (&(fdesc->dec_num), sizeof (fdesc->dec_num), 1, fp);	fwrite (&(fdesc->reserved2), sizeof (fdesc->reserved2), 1, fp);	fwrite (&(fdesc->work_id), sizeof (fdesc->work_id), 1, fp);	fwrite (&(fdesc->reserved3), sizeof (fdesc->reserved3), 1, fp);	fwrite (&(fdesc->set_fields), sizeof (fdesc->set_fields), 1, fp);	fwrite (&(fdesc->reserved4), sizeof (fdesc->reserved4), 1, fp);	fwrite (&(fdesc->mdx_tag), sizeof (fdesc->mdx_tag), 1, fp);}/* * update a field header */static int io_update_field (DBF *db, WORD field_num) {	long int pos, new_pos;	/* changing is not allowed in READ mode	 */	if (!(db->access_mode & DB_WRITE)) {		return (E_WRONG_MODE);	}	/* remember the position and go to the beginning of the field to change	 */	pos = ftell (db->fp);	new_pos = sizeof (db_header) + (field_num * sizeof (db_field));	fseek (db->fp, new_pos, SEEK_SET);	io_write_field_desc (db->fields[field_num], db->fp);	/* mv the file pointer back to the previous position	 */	fseek (db->fp, pos, SEEK_SET);	return (TRUE);}/* */static void io_write_header (db_header *head, FILE *fp) {	long pos;	/* remember the position and go to the beginning */	pos = ftell (fp);	rewind (fp);	fwrite (&(head->type), sizeof (UCHAR), 1, fp);	fwrite (&(head->lm_yy), sizeof (UCHAR), 1, fp);	fwrite (&(head->lm_mm), sizeof (UCHAR), 1, fp);	fwrite (&(head->lm_dd), sizeof (UCHAR), 1, fp);	fwrite4bytes (&(head->num_of_recs), fp);	fwrite2bytes (&(head->header_size), fp);	fwrite2bytes (&(head->record_size), fp);	fwrite (&(head->reserved1), sizeof(head->reserved1), 1, fp);	fwrite (&(head->transaction), sizeof(UCHAR), 1, fp);	fwrite (&(head->crypted), sizeof(UCHAR), 1, fp);	fwrite (&(head->net), sizeof(head->net), 1, fp);	fwrite (&(head->mdx), sizeof(UCHAR), 1, fp);	fwrite (&(head->code), sizeof(UCHAR), 1, fp);	fwrite (&(head->reserved2), sizeof(head->reserved2), 1, fp);	/* go back */	fseek (fp, pos, SEEK_SET);}/* * write a new header (main header plus field headers) */static int io_write_new_header (DBF *db)
{	register unsigned int i;
	time_t t;	struct tm *tm;	if (!(db->access_mode & DB_WRITE))
		return (FALSE);	time (&t);	tm = localtime (&t);	db->head->lm_yy = (UCHAR) (tm->tm_year);	db->head->lm_mm = (UCHAR) (tm->tm_mon + 1);	db->head->lm_dd = (UCHAR) (tm->tm_mday);	io_write_header (db->head, db->fp);

	fseek (db->fp, sizeof(db_header), SEEK_SET);	for (i = 0; i < db->num_of_fields; i++) {		io_write_field_desc(db->fields[i], db->fp);	}
		fputc (EO_FDESC, db->fp);
	return TRUE;}/* * update the main header, e.g. when adding a record */static int update_header (DBF *db)
{	time_t t;	struct tm *tm;	if (!(db->access_mode & DB_WRITE))
		return (FALSE);	time (&t);	tm = localtime (&t);	db->head->lm_yy = (UCHAR) (tm->tm_year);	db->head->lm_mm = (UCHAR) (tm->tm_mon + 1);	db->head->lm_dd = (UCHAR) (tm->tm_mday);	io_write_header (db->head, db->fp);	return (TRUE);}/* * close the xbase file */int FAR EXPORT dbClose (int handle) {	DBF *db;	db = num2db (handle);	if (db != NULL) {		if (db->access_mode & DB_WRITE) {			db->head->transaction = 0;			update_header (db);		}		if (db->idx != NULL) {			fclose(db->idx->fp);		}		if (fclose (db->fp) == 0) {			rm_dbf_from_list (db);			return (TRUE);		} else {			rm_dbf_from_list (db);			return (E_IO);		}	}	fprintf (stderr, "dbClose (): wrong handle %d\n", handle);	return (E_HANDLE);}/* * returns the number of fields in a xbase-file specified by 'handle' */int FAR EXPORT dbGetNumOfFields (int handle) {	DBF *db;	db = num2db (handle);	if (db != NULL) {		return (db->num_of_fields);	}	return (E_HANDLE);}/* * returns the number of records in the xbase-file */DWORD FAR EXPORT dbGetNumOfRecs (int handle) {	DBF *db;	db = num2db (handle);	if (db != NULL) {		return (db->head->num_of_recs);	}	dberrno = E_HANDLE;	return (0);}/* * returns the length of the specified field */int FAR EXPORT dbGetFieldLength (int handle, WORD num) {	DBF *db;	db = num2db (handle);	if (db != NULL) {		if (num <= db->num_of_fields)			return (db->fields[num-1]->length);		else {			return (E_FLD_NR);		}	}	return (E_HANDLE);}/* * returns the number of decimal places */int FAR EXPORT dbGetFieldDec (int handle, WORD num) {	DBF *db;	db = num2db (handle);	if (db != NULL) {		if (num <= db->num_of_fields)			return (db->fields[num-1]->dec_num);		else {			return (E_FLD_NR);		}	}	return (E_HANDLE);}/* * returns the type of the specified field */char FAR EXPORT dbGetFieldType (int handle, WORD num) {	DBF *db;	db = num2db (handle);	if (db != NULL) {		if (num <= db->num_of_fields)			return (db->fields[num-1]->type);		else			return (E_FLD_NR);	}	return (FT_UNKNOWN);}/* * returns the name of the field specified by 'num' */const UCHAR FAR *dbGetFieldName (int handle, WORD num) {	DBF *db;	db = num2db (handle);	if (db != NULL) {		if ((num > db->num_of_fields) || (num < 1)) {			dberrno = E_FLD_NR;			return (NULL);		}		return (db->fields[num-1]->name);	}	return (NULL);}/* * returns the number of the named field */int EXPORT dbGetFieldNum (int handle, const char *name) {	DBF *db;	db_field *fld;	int i;	int num = 0;	int len0, len1;	db = num2db(handle);	if (db == NULL)  {		return (E_HANDLE);	}	len0 = (int) strlen(name);	for (i = 0; i < db->num_of_fields; i++) {		fld = db->fields[i];		len1 = (int) strlen ((char *)fld->name);		if (len0 == len1) {			if (strncmp (name, (char*) fld->name, len0) == 0) {				num = i+1;			}		}	}	return (num);}/* * returns the field name but expanded to the maximum field name * length (10) filled up with white spaces .. * returned pointer must be free()'ed */UCHAR FAR EXPORT *dbGetExFieldName (int handle, WORD num) {	DBF *db;	UCHAR *s;	int len, max;	db = num2db (handle);	if (db != NULL) {		if ((num > db->num_of_fields) || (num < 1))			return (NULL);		max = db->fields[num-1]->length;		if (max < MAX_NAME_LEN) { 			/* if the field length is very short, e.g. BOOLEAN fields */			max = MAX_NAME_LEN;		}		s = (UCHAR *) malloc (max+1);		if (!s) {			perror ("dbGetExFieldName()");			return (NULL);		}		len =  (int) strlen ((const char *) db->fields[num-1]->name);		memcpy (s, db->fields[num-1]->name, len+1);		len = max - len;		while (len) {			s[max - len] = ' ';			len--;		}		s[max] = '\0';		return (s);	}	return (NULL);}/* * return the mode of the file */int FAR EXPORT dbGetMode (int handle) {	DBF *db;	db = num2db (handle);	if (db != NULL) {		return (db->access_mode);	}	return (0);}/* * */int FAR EXPORT dbGetType (int handle) {	DBF *db;	db = num2db (handle);	if (db == NULL)		return (0);	return ((int) db->head->type);}/* * create a new xbase file * not ready until now! */int FAR EXPORT  dbCreate(char *fname, WORD num_of_fields, UCHAR type)
{	FILE *fp;	DBF* db;	size_t len;	int rc;	if (num_of_fields < 1) {		return (E_FLD_NR);	}	fp = fopen (fname, "wb+");	if (fp == NULL) {		perror (fname);		return (E_IO);	}	db = alloc_dbf (num_of_fields);	if (db == NULL) {		fclose (fp);		return (E_ALLOC);	}	len = strlen (fname);	if (len > sizeof(db->file_name) - 1) {		free_dbf(db);		fclose (fp);		return (E_IO);	}	strncpy (db->file_name, fname, len+1);	db->fp = fp;	db->access_mode = DB_WRITE;	if (type & DB_FOXPRO)
	{		db->access_mode |= DB_FOXPRO;		db->head->code = 0x03;	/* windows ANSI as default */	}
	else
		db->head->code = 0;	db->memoflag = 0;	db->head->type = 0x03;  /* 0x03 = dbf III */	db->head->lm_yy = 0x0;	db->head->lm_mm = 0x0;	db->head->lm_dd = 0x0;	db->head->num_of_recs = 0x0;	db->head->header_size = 32 + (32 * num_of_fields) + sizeof (EO_FDESC);	db->head->record_size = 0x0;	db->head->transaction = 0x1;	db->head->crypted     = 0x0;	db->head->mdx         = 0x0;	io_write_new_header (db);	rc = add_dbf_to_list(db);	if (!rc) {		fclose(db->fp);		free_dbf(db);		return (E_HANDLE);	}	return (rc);}/* * write /update memo header */static int io_write_memo_header(DBF* db) {	DWORD n[2];	rewind (db->memo->fp);	n[0] = db->memo->next_free;	n[1] = db->memo->block_size;	#ifdef LSB_HOST	n[0] = Swap4Bytes(n[0]);	n[1] = Swap4Bytes(n[1]);	#endif	fwrite(n, sizeof(DWORD), 2, db->memo->fp);	fwrite(db->memo->fill, sizeof(db->memo->fill), 1, db->memo->fp);	return (TRUE);}/* * set the values of a new field, must be called imidiatly after * 'dbCreate()'! */int FAR EXPORT dbInitField (int handle, WORD field_num, UCHAR *name, UCHAR type, UCHAR length, UCHAR dec_num) {	DBF *db;	db_field *field;	register unsigned int i;	WORD len_of_field_name;	db = num2db (handle);	if (db == NULL) {		return (E_HANDLE);	}	if (db->num_of_fields < field_num) {		return (E_REC_NR);	}	if (db->head->num_of_recs > 0) {		/* there are records in the xbase file,		 * so changing of the field is not allowed!		 */		return (FALSE);	}	field = db->fields[field_num-1];	len_of_field_name = strlen((char*)name);	if (len_of_field_name > sizeof(field->name)-1) {		len_of_field_name = sizeof(field->name)-1;	}	strncpy ((char *) field->name, (char *) name, len_of_field_name);	field->name[len_of_field_name] = '\0';	for (i = 0; i < (sizeof(field->name) - 1); i++) {		if (name[i] == '\0')			break;		field->name[i] = (char) toupper ((int) field->name[i]);	}	field->type = type;	field->length = length;		switch (field->type) {		case FT_CHARS:			field->length = min (field->length, 254);			break;		case FT_DATE:			field->length = 8;			break;		case FT_FLOAT:		case FT_NUMBER:			field->length = min (field->length, 20);			field->dec_num = min(field->length-1, dec_num);			break;		case FT_BOOLEAN:			field->length = 1;			break;		case FT_MEMO:		case FT_GENERAL:			/* objects are also saved in memo files */		case FT_OBJECT:		case FT_PICTURE:			field->length = 10;			if (db->memoflag == FALSE)
			{				/* */				if (db->access_mode & DB_FOXPRO)
				{					db->memoflag = MEMO_FOXPRO;					db->head->type = 0xF5;				}
				else
				{					db->memoflag = MEMO_DBASE;					db->head->type = 0x83;				}				db->memo = alloc_memo(db->file_name, db->memoflag);				db->memo->fp = fopen (db->memo->file_name, "wb+");				if (db->memo->fp == NULL)
				{					perror (db->memo->file_name);					free_memo(db->memo);					db->memoflag = FALSE;				}
				else
				{					/* write a new memo header */					io_write_memo_header(db);				}			}			break;		default:			break;	}	db->offset[0] = 1;	for (i = 0, db->head->record_size = 1; i < db->num_of_fields; i++) {		db->head->record_size += ((WORD) db->fields[i]->length);		if (i > 0)			db->offset[i] = db->offset[i-1] + db->fields[i-1]->length;	}	if ((io_update_field(db, field_num-1)) == TRUE) {		return (update_header (db));	} else {		return (FALSE);	}}/* * set the configuration for the xbase file named by 'handle' * whether deleted records should be shown */int FAR EXPORT dbSetShowDel (int handle, int mode) {	DBF *db;	db = num2db (handle);	if (db != NULL) {		if (mode == TRUE) {			db->access_mode &= (~DB_IGNORE_DEL);		} else {			db->access_mode |= DB_IGNORE_DEL;		}		return (TRUE);	}	return (E_HANDLE);}/* * use or do not use memo files, dirty hack until now! */int FAR EXPORT dbSetUseMemo (int handle, int mode) {	DBF *db;	db = num2db (handle);	if (db != NULL) {		db->memoflag = mode;		return (TRUE);	}	return (E_HANDLE);}/* * returns the raw data of the next record, NO ending '\0' * is added! 'nob' returns the number of bytes of the * raw data pointer. */static UCHAR *io_raw_next (DBF *db, WORD *nob) {	UCHAR *input;	*nob = db->head->record_size;	input = (UCHAR *) malloc ((sizeof (UCHAR) * *nob)+1);	if (input == NULL) {		dberrno = E_ALLOC;		*nob = 0;		return (NULL);	}	db->current++;	fread (input, sizeof (UCHAR), *nob, db->fp);	if (ferror(db->fp) || feof (db->fp)) {		clearerr (db->fp);		free(input);		return (NULL);	}	input[*nob] = '\0';	return (input);}/* * read the named field of the current record * first field: fld = 0 */static UCHAR *io_read_field (DBF *db, WORD fld, DWORD *nob) {	UCHAR *str;	DWORD len;	len = db->fields[fld]->length;	str = (UCHAR *) malloc (len + 1);	if (str != NULL) {		str[len] = '\0';		fseek (db->fp, db->offset[fld], SEEK_CUR);		fread (str, sizeof(char), len, db->fp);		fseek (db->fp, -(db->offset[fld] + len), SEEK_CUR);		*nob = len;	}	#ifdef DEBUG	fprintf(stderr, "DEBUG> io_read_field(): db->current=%ld, fld=%d\n", db->current, fld);	#endif	return (str);}/* */static int db_raw_write (DBF *db, UCHAR *record, WORD nob) {	db->current++;	fwrite (record, sizeof(UCHAR), nob, db->fp);	if (ferror(db->fp) || feof (db->fp)) {		clearerr (db->fp);		return (FALSE);	}	return (TRUE);}/* * returns the raw data of the next record, NO ending '\0' * is added! 'num_of_bytes' returns the number of bytes of the * raw data pointer. */UCHAR FAR* EXPORT dbRawNext (int handle, WORD *num_of_bytes) {	DBF *db;	db = num2db (handle);	if (db != NULL) {		return (io_raw_next (db, num_of_bytes));	}	#ifdef DEBUG		fprintf (stderr, "dbRawNext(): wrong handle %d\n", handle);	#endif	dberrno = E_HANDLE;	*num_of_bytes = 0;	return (NULL);}/* * find and return a memo field */static DWORD get_memo (db_memo *m, int num, UCHAR **entry) {	db_memo_entry mfield;	DWORD rc = 0;#ifdef DEBUG3	fprintf (stderr, "DEBUG3> get_memo(): num=%d block size=%d\n", num, m->block_size);#endif	if (num > 0) {		if (fseek (m->fp, num * m->block_size, SEEK_SET) !=0) {			perror (m->file_name);			return (FALSE);		}		fread (&(mfield.num), sizeof (mfield.num), 1, m->fp);		fread (&(mfield.len), sizeof (mfield.len), 1, m->fp);		#ifdef LSB_HOST		mfield.num = (DWORD) Swap4Bytes (mfield.num);		mfield.len = (DWORD) Swap4Bytes (mfield.len);		#endif		*entry = (UCHAR *) malloc ((size_t) (mfield.len+(UCHAR)1));		if (*entry == NULL) {			dberrno = E_ALLOC;			return (0);		}		rc = (DWORD) fread (*entry, sizeof(UCHAR), (size_t) mfield.len, m->fp);		if (rc != mfield.len) {			fprintf (stderr, "error in get_memo()\n");		}		(*entry)[mfield.len] = (UCHAR) '\0';	} else {		*entry = (UCHAR *) calloc (1, sizeof (UCHAR));		return (0);	}#ifdef DEBUG3	fprintf(stderr, "DEBUG3> get_memo(): len = %ld\n", rc);#endif	return (mfield.len);}/* * returns the seperated field from the raw read record 'raw' * pointed to by 'num'. */static UCHAR *sep_field_by_num (UCHAR* raw, WORD num, DBF *db) {	UCHAR *field;	UCHAR *offset;	UCHAR n[11];#ifdef DEBUG3	fprintf (stderr, "DEBUG3> sep_field_by_num(): num = %d\n", num);#endif	/* calculate the offset pointer where the field begins */	offset = raw + db->offset[num];	switch (db->fields[num]->type) {		case FT_CHARS:		case FT_FLOAT:		case FT_BOOLEAN:		case FT_NUMBER:		case FT_DATE:			field = (UCHAR *) malloc ((size_t) db->fields[num]->length+1);			if (field != NULL) {				memcpy (field, offset, db->fields[num]->length);				field[db->fields[num]->length] = '\0';			}			break;		case FT_MEMO:			if (db->memoflag != FALSE) {				n[10] = '\0';				memcpy (n, offset, 10);				get_memo (db->memo, atoi((const char*)n), &field);			} else {				field = (UCHAR *) calloc (1, sizeof (UCHAR));			}			break;		default:			#ifdef DEBUG			fprintf (stderr, DBF_LIB_VERSION				": field type not supported: %c\n", db->fields[num]->type);			#endif			/*			 * nevertheless copy the field stuff as it would be an normal			 * field, to avoid core dumps :-)			 */			field = (UCHAR *) malloc ((size_t) db->fields[num]->length+1);			if (field != NULL) {				memcpy (field, offset, db->fields[num]->length);				field[db->fields[num]->length] = '\0';			}			break;	}	return (field);}/* * convert a binary field to hex valued ascii string */static UCHAR *obj2hex (UCHAR *obj, int len) {	UCHAR *str, *p;	int i;	str = (UCHAR *) malloc (len*2 +1);	if (str != NULL) {		str[len*2] = '\0';		p = str;		for (i = 0; i < len; i++) {			sprintf ((char *)p, "%02X", *obj);			obj++;			p += 2;			i += 2;		}	}	return (str);}/* * returns the seperated field pointed to by 'raw'. * spaces before and behind the field are trimmed! */static UCHAR *rawTrToAscii (UCHAR* raw, UCHAR len, UCHAR type, DBF *db) {	UCHAR *field, *p, *obj;	int length;#ifdef DEBUG3	fprintf (stderr, "DEBUG3> rawTrToAscii(): field len: %d, field type: %c\n", len, type);	if (len == 0) {		fprintf (stderr, "DEBUG3> ouch!! field len = 0!?\n");	}#endif	switch (type) {		case FT_CHARS:			p = raw+len-1;			while ((*p == ' ') && (len > 0)) {				*p-- = '\0';				len--;			}			field = (UCHAR *) malloc ((size_t) len+1);			if (field == NULL) {				break;			}			memcpy (field, raw, len);			field[len] = '\0';			break;		case FT_MEMO:			if (db->memoflag != FALSE) {				p = (UCHAR *) malloc (len+1);				if (p != NULL) {					memcpy(p, raw, len);					p[len] = '\0';					get_memo (db->memo, atoi((const char*)p), &field);					free (p);				} else {					field = NULL;				}			} else {				field = (UCHAR *) calloc (1, sizeof (UCHAR));			}			break;		case FT_GENERAL:			if (db->memoflag != FALSE) {				p = (UCHAR *) malloc (len+1);				if (p != NULL) {					memcpy(p, raw, len);					p[len] = '\0';					length =  (int) get_memo (db->memo, atoi((const char*)p), &obj);					free (p);					field = obj2hex (obj, length);					free (obj);				} else {					field = NULL;				}			} else {				field = (UCHAR *) calloc (1, sizeof (UCHAR));			}			break;		case FT_FLOAT:		case FT_NUMBER:			p = raw;			while ((*p == ' ') && (len > 0)) {				p++;				len--;				if (len == 0)					break;			}			field = (UCHAR *) malloc ((size_t)len+1);			memcpy(field, p, len);			field[len] = '\0';			break;		case FT_DATE:			if (*raw == ' ') {				/* it's empty! */				field = (UCHAR *) calloc ((size_t)1, sizeof (UCHAR));			} else {				field = (UCHAR *) calloc ((size_t)len + 3, sizeof (UCHAR));				field[0] = *(raw+6);				field[1] = *(raw+7);				field[2] = DEF_DATE_SEPERATOR;				field[3] = *(raw+4);				field[4] = *(raw+5);				field[5] = DEF_DATE_SEPERATOR;				field[6] = *(raw);				field[7] = *(raw+1);				field[8] = *(raw+2);				field[9] = *(raw+3);			}			break;		case FT_BOOLEAN:			field = (UCHAR *) malloc (2);			switch (*raw) {				case ' ':				case '?':					field[0] = '\0';					break;				case 'T':				case 't':				case 'Y':				case 'y':					field[0] = 'T';					break;				case 'F':				case 'f':				case 'N':				case 'n':					field[0] = 'F';					break;				default:					break;			}			field[1] = '\0';			break;		default:			#ifdef DEBUG			fprintf (stderr, DBF_LIB_VERSION ": field type not supported: %c\n", type);			#endif			/*			 * nevertheless copy the field stuff as it would be an normal			 * field, to avoid core dumps :-)			 */			field = (UCHAR *) malloc ((size_t)len+1);			memcpy (field, raw, len);			field[len] = '\0';			break;	}	return (field);}/* * go 'num' records forward or backward */static int io_wind (DBF *db, long int num) {	long pos;	pos = ftell (db->fp);	if (pos < (long) db->head->header_size) {		fprintf (stderr, "io_wind(): fatal error\n");		return (E_REC_NR);	}	if (fseek (db->fp, num * db->head->record_size, SEEK_CUR) == 0) {		db->current += num;		#ifdef DEBUG		fprintf (stderr, "DEBUG> io_wind(): current=%ld\n", db->current);		#endif		return (TRUE);	} else {		/* something failed, so go back .. */		fseek (db->fp, pos, SEEK_SET);		return (E_IO);	}}/* * */UCHAR FAR* EXPORT dbRawField (int handle, WORD num) {	DBF *db;	UCHAR *field, *raw;	WORD nob;	db = num2db(handle);	if (db == NULL) {		dberrno = E_HANDLE;		return (NULL);	}	if (num > db->num_of_fields) {		dberrno = E_FLD_NR;		return (NULL);	}	if (db->current > db->head->num_of_recs) {		dberrno = E_REC_NR;		return (NULL);	}	raw = io_raw_next(db, &nob);	io_wind(db, -1);	if (raw == NULL) {		dberrno = E_ALLOC;		return (NULL);	}	field = sep_field_by_num(raw, num-1, db);	if (field == NULL) {		dberrno = E_ALLOC;	}	free (raw);	return (field);}/* * returns the current position */DWORD FAR EXPORT dbCurrent (int handle) {	DBF *db;	db = num2db (handle);	if (db == NULL) {		return (0);	}	return (db->current);}/* * are we at end of file? */int EXPORT dbEof (int handle) {	DBF *db;	db = num2db (handle);	if (db == NULL) {		return (E_HANDLE);	}	return (db->current == (db->head->num_of_recs+1) ? 1 : 0);}/* * go 'num' records forward or backward in the xbase file */int FAR EXPORT dbWind (int handle, long int num) {	DBF *db;	db = num2db (handle);	if (db != NULL) {		return (io_wind (db, num));	}	return (E_HANDLE);}/* * returns the field content by number of the current * record in the xbase file */UCHAR FAR EXPORT *dbSelByNumber (int handle, WORD number, int go) {	DBF *db;	UCHAR *field, *raw;	WORD num;	num = 0;	field = NULL;	db = num2db (handle);	if (db != NULL) {		raw = io_raw_next (db, &num);		if (raw != NULL) {			/* the first character indicates if it is deleted */			if ((*raw == DEL_FLAG) && (db->access_mode & DB_IGNORE_DEL)) {				*raw = '\0';				return (raw);			}			number--; /* cause dbSelByNumber( .., 1, ..) is the						first field which is internal the 0th field */			field = sep_field_by_num (raw, number, db);			free (raw);			if (go == FALSE)				io_wind (db, -1);			return (field);		}	} else {		dberrno = E_HANDLE;	}	return (NULL);}/* * returns the field of the next record specified by 'name' as a string * white spaces are trimmed .. * 'go = FALSE' will NOT go to the next record after reading */UCHAR FAR EXPORT *dbTrSelByName (int handle, const char* name, int go) {	DBF *db;	UCHAR *field, *raw;	db_field *fld;	int offset;	WORD i, num;	offset = 1;	field = NULL;	db = num2db (handle);	if (db != NULL) {		for (i = 0; i < db->num_of_fields; i++) {			fld = db->fields[i];			if (strncmp (name, (char*) fld->name, strlen(name)) == 0) {				raw = io_raw_next (db, &num);				if (raw != NULL) {					/* the first character indicates if it is deleted */					if ((*raw == DEL_FLAG) && (db->access_mode & DB_IGNORE_DEL)) {						*raw = '\0';						return (raw);					}					field = rawTrToAscii (raw+offset, fld->length, fld->type, db);					free (raw);					if (go == FALSE)						io_wind (db, -1);					return (field);				}			}			offset += fld->length;		}	} else {		dberrno = E_HANDLE;	}	return (NULL);}/* * goto record 'nr' */static int io_goto (DBF *db, DWORD num) {	DWORD offset;	#ifdef DEBUG		fprintf (stderr, "DEBUG> io_goto(): num=%lu, current=%ld\n", num, db->current);	#endif	num--;  /* 1 = the first record */	if ((num < db->head->num_of_recs) || (num == 0)) {		offset = db->head->header_size + (num * db->head->record_size);		fseek (db->fp, (long) offset, SEEK_SET);		db->current = num+1;		return (TRUE);	}	#ifdef DEBUG		else {		fprintf (stderr, "DEBUG> io_goto(): %lu not allowed\n", num+1);	}	#endif	return (E_REC_NR);}/* * check, if a record is deleted * nr = CURRENT checks the current record */static int io_is_del (DBF *db, DWORD nr) {	DWORD pos = 0;	int c;	if (nr != CURRENT) {		pos = db->current;		if (io_goto (db, nr) != TRUE) {			return (E_REC_NR);		}	}	c = fgetc(db->fp);	ungetc(c, db->fp);	if (nr != CURRENT) {		/* go back */		if (pos == db->head->num_of_recs+1) {			io_goto (db, pos-1);			io_wind (db, 1);		} else {			io_goto (db, pos);		}	}	switch (c) {		case DEL_FLAG:			return (TRUE);		case DOS_EOF:			return (E_REC_NR);		case EOF:			return (E_IO);		default:			return (FALSE);	}}/* * returns the field content by number of the current * record in the xbase file, white spaces are trimmed */UCHAR FAR EXPORT *dbTrSelByNumber (int handle, WORD fld_no, int go) {	DBF *db;	UCHAR *field, *raw;	DWORD num;	num = 0;	field = NULL;	db = num2db (handle);	if (db != NULL) {		#ifdef DEBUG		fprintf (stderr, "DEBUG> dbTrSelByNumber: current=%ld, max=%ld\n",					db->current, db->head->num_of_recs);		#endif		/* oops */		if (db->current > db->head->num_of_recs) {			dberrno = E_REC_NR;			return (NULL);		}		if ((io_is_del(db, CURRENT)==TRUE) && (db->access_mode & DB_IGNORE_DEL)){			raw = (UCHAR *) malloc (1);			if (raw != NULL)				*raw = '\0';			return (raw);		}		fld_no--; /* cause dbTrSelByNumber( .., 1, ..) is the        			first field which is internal the 0th field */		raw = io_read_field (db, fld_no, &num);		if (raw != NULL) {			field = rawTrToAscii (raw, db->fields[fld_no]->length, db->fields[fld_no]->type, db);			free (raw);			if (go == TRUE)				io_wind (db, 1);			return (field);		}	} else {		dberrno = E_HANDLE;	}	return (NULL);}/* * return the next record without stripping the white chars, * but convert the date field to dd.mm.yyyy */UCHAR FAR EXPORT *dbStrNext (int handle, char seperator) {	DBF *db;	UCHAR *str, *raw, *p, *q;	WORD length;	UCHAR i, w;	int extra;	db = num2db (handle);	if (db == NULL) {		return (NULL);	}	str = NULL;	raw = io_raw_next (db, &length);	if (raw != NULL) {		if ((*raw == DEL_FLAG) && (db->access_mode & DB_IGNORE_DEL)) {			*raw = '\0';			return (raw);		}		extra = 0;		for (i = 0; i< db->num_of_fields; i++)			if (db->fields[i]->type == FT_DATE) {				/* reserve extra space for date conversion				 */				extra++;			}		str = (UCHAR *) malloc ( (size_t) length +									db->num_of_fields + (extra * 2) );		if (str == NULL) {			return (str);		}#ifdef DEBUG2		fprintf(stderr, "DEBUG2> dbStrNext(): buff len = %d\n", length + db->num_of_fields + (extra * 2));#endif		p = str;		q = raw;		q++;	/* cause of the "*" at the first position */		for (i = 0; i < db->num_of_fields; i++) {			w = db->fields[i]->length;			switch (db->fields[i]->type) {			case FT_DATE:				memcpy (p, q+6, 2);				p[2] = DEF_DATE_SEPERATOR;				memcpy (p+3, q+4, 2);				p[5] = DEF_DATE_SEPERATOR;				memcpy (p+6, q, 4);				p += w + 2;				break;			default:				memcpy (p, q, w);				p += w;				break;			}			*p = seperator;			p++;			q += w;		}		p--; *p = '\0';		free (raw);	}	return (str);}/* * returns the next record as an ascii-string, * seperated by 'seperator' */UCHAR FAR EXPORT *dbTrStrNext (int handle, char seperator) {	DBF *db;	UCHAR *raw, *line, *tmp;	db_field *field;	int base;	WORD length, i;	size_t len;	line = NULL;	db = num2db (handle);	if (db == NULL) {		return (NULL);	}	raw = io_raw_next (db, &length);	if (raw != NULL) {		if ((*raw == DEL_FLAG) && (db->access_mode & DB_IGNORE_DEL)) {			*raw = '\0';			return (raw);		}		base = 0;
		len = 0L;		for (i = 0; i < db->num_of_fields; i++) {			field = db->fields[i];#ifdef DEBUG3			fprintf (stderr, "DEBUG3> dbTrStrNext(): field len: %d\n", field->length);#endif			tmp = rawTrToAscii (raw+db->offset[i], field->length, field->type, db);			len = strlen ((char*) tmp);			if (i > 0) {				*(line+base) = seperator;				base++;			}			line = (UCHAR *) realloc (line, sizeof (UCHAR) * (base+len+1));			memcpy (line+base, tmp, len);			free (tmp);			base += (int) len;		}		*(line+base) = '\0';		free (raw);	} else {#ifdef DEBUG2		fprintf (stderr, "DEBUG2> dbTrStrNext(): raw = NULL\n");#endif	}	return (line);}/* * Goto the record 'num' */int FAR EXPORT dbGotoNr (int handle, DWORD num) {	DBF *db;	db = num2db (handle);	if (db != NULL) {		return (io_goto (db, num));	}	return (E_HANDLE);}/* * add a new blank record to the xbase file * return codes: *      record number: if all works fine :) *              FALSE: some error is there .. *                     in this case the extern variable dberrno is *                     set to E_HANDLE or E_ALLOC */DWORD FAR EXPORT dbAppendBlank (int handle) {	DBF *db;	long int offset;	register int size, i;	UCHAR *rec, *p;	db = num2db (handle);	if (db != NULL) {		if (!(db->access_mode & DB_WRITE)) {			dberrno = E_WRONG_MODE;			return (FALSE);		}		/* alloc ram for a new record line */		rec = (UCHAR *) malloc (db->head->record_size+1);		if (rec == NULL) {			dberrno = E_ALLOC;			return (FALSE);		}		p = rec;		size = db->head->record_size;		while (size) {			*p = ' ';			p++;			size--;		}		for (i = 0; i < db->num_of_fields; i++) {			/* initialize boolean fields */			if (db->fields[i]->type == FT_BOOLEAN) {				rec[db->offset[i]] = '?';			}		}		*p = DOS_EOF;		offset = db->head->header_size + (db->head->num_of_recs * db->head->record_size);		/* go behind the last record		 */		i = fseek (db->fp, offset, SEEK_SET);		fwrite (rec, sizeof (UCHAR), db->head->record_size+1, db->fp);		free (rec);		db->head->num_of_recs++;		update_header (db);		return (db->head->num_of_recs);	} else {		dberrno = E_HANDLE;		return (FALSE);	}}/* * convert a number to a string, constant field length = 10 + '\0' */static char *dword2str (DWORD num) {	char *s;	s = (char *) malloc (11);	sprintf (s, "%10lu", num);	return (s);}/* * add an entry to a memo file */static DWORD add_memo_entry(DBF *db, const char *str) {	int len;	DWORD ref;	db_memo_entry mm;	if (str == NULL)		return (FALSE);	len = (int) strlen(str);	if (len == 0)		return (FALSE);	mm.buf = (char*) calloc((size_t)db->memo->block_size, sizeof(char));	if (mm.buf == NULL)		return (FALSE);	ref = db->memo->next_free;	mm.num = 0x01; /* 1 = memo, 2 = object .. */	mm.len = len;	fseek (db->memo->fp, db->memo->next_free * db->memo->block_size, SEEK_SET);#ifdef LSB_HOST	mm.num = Swap4Bytes(mm.num);	mm.len = Swap4Bytes(mm.len);#endif	memcpy(mm.buf, &mm.num, sizeof(mm.num));	memcpy(mm.buf+4,&mm.len,sizeof(mm.len));	if (len > (int) db->memo->block_size - 8) {		memcpy (mm.buf+8, str, (size_t)db->memo->block_size-8);	} else {		memcpy (mm.buf+8, str, len);	}	fwrite (mm.buf, sizeof(UCHAR), (size_t)db->memo->block_size, db->memo->fp);	len -= (int)(db->memo->block_size - 8);	db->memo->next_free++;	str += (db->memo->block_size - 8);	while (len > 0) {		if (len > (int) db->memo->block_size) {			memcpy (mm.buf, str, (size_t)db->memo->block_size);		} else {			memset (mm.buf, 0, (size_t)db->memo->block_size);			memcpy (mm.buf, str, len);		}		fwrite (mm.buf, sizeof(UCHAR), (size_t)db->memo->block_size, db->memo->fp);		str += db->memo->block_size;		db->memo->next_free++;		len -= (int)db->memo->block_size;	}	io_write_memo_header(db);	return (ref);}/* */static char *prep_number (double num, int len, int dec) {	char *ns;	char form[10];	ns = (char *) malloc (len +1);	if (ns != NULL) {		ns[len] = '\0';	}	sprintf (form, "%%%d.%dlf", len, dec);	sprintf (ns, form, num);	return (ns);}/* */static char *prep_date (int dd, int mm, int yy) {	char *ns;	ns = (char *) malloc (8+1);	if (ns != NULL) {		if (dd > 31 || dd < 0)			dd = 0;		if (mm > 12 || mm < 0)			mm = 0;		if (yy > 9999 || yy<0)			yy = 0;		sprintf (ns, "%04d%02d%02d", yy, mm, dd);	}	return (ns);}/* */static char *prep_chars (const char *s, int len) {	register int size;	char *ns;	size = (int) strlen (s);	if (size > len) {		fprintf (stderr, "Warning: string too long!\n");	}	size = min (size, len);	ns = (char *) malloc (len+1);	if (ns != NULL) {		memcpy(ns, s, size);		ns[len] = '\0';		/* fill up with spaces */		while (size < len) {			ns[size] = ' ';			size++;		}	}	return (ns);}/* * change content of a field, "data" must be a pointer to the * corresponding type, e.g. if the field is type FT_CHARS it * must be a char pointer or FT_NUMBER it must be a pointer to long .. * * not  ready! * * FT_CHARS ->	char*	->	"foo bar .." * FT_DATE	->	long*	->	YYYYMMDD * FT_FLOAT	->	double*	->	double value * FT_BOOLEAN ->char*	->	'T', 't', 'F', 'f', 'y', 'Y', 'N', 'n' * FT_MEMO	->	char*	->	"foo bar .." * FT_NUMBER ->	long*	->	long value */int FAR EXPORT dbChangeFieldRaw (int handle, DWORD nr, WORD num, void *data)
{	DBF *db;	int rc;	rc = TRUE;	db = num2db(handle);	if (db == NULL) {		return (E_HANDLE);	}	if (!db->access_mode & DB_WRITE) {		return (E_WRONG_MODE);	}	if (num > db->num_of_fields) {		return (E_REC_NR);	}	if (data == NULL) {		return (E_UNKNOWN);	}	if (io_goto (db, nr)) {		fseek (db->fp, db->offset[num-1], SEEK_CUR);	} else {		return (E_UNKNOWN);	}	switch (db->fields[num-1]->type) {		char *str;		const char *ds;		case FT_CHARS:			str = prep_chars ((const char *)data, db->fields[num-1]->length);			fwrite (str, sizeof (UCHAR), db->fields[num-1]->length, db->fp);			free (str);			break;		case FT_BOOLEAN:			str = (char *) malloc (1);			ds = (const char *) data;			if (*ds=='T' || *ds=='t' || *ds=='Y' || *ds=='y') {				*str = 'T';				fwrite (str, sizeof (UCHAR), 1, db->fp);			} else if (				*ds=='F' || *ds=='f' || *ds=='N' || *ds=='n') {				*str = 'F';				fwrite (str, sizeof (UCHAR), 1, db->fp);			} else {				rc = E_FLD_TYPE;			}			free (str);			break;		case FT_DATE:		case FT_FLOAT:		case FT_MEMO:		case FT_NUMBER:		case FT_GENERAL:		case FT_UNKNOWN:		default:			fprintf (stderr,				"dbChangeFieldRaw(): Field type '%c' not supported until now\n", db->fields[num-1]->type);			break;	}	/* go back .. */	fseek (db->fp, db->offset[num-1], SEEK_CUR);	return (TRUE);}/* * change the field of a record * not ready! NUMBER and CHARS seems to work .. */int FAR EXPORT dbChangeField (int handle, DWORD nr, WORD num, char *data)
{	DBF *db;	int rc;	rc = TRUE;	db = num2db (handle);	if (db != NULL) {		if (!db->access_mode & DB_WRITE) {			dberrno = E_WRONG_MODE;			return (FALSE);		}		if (num > db->num_of_fields) {			return (E_REC_NR);		}		if (io_goto (db, nr)) {			fseek (db->fp, db->offset[num-1], SEEK_CUR);		} else {			return (E_REC_NR);		}		switch (db->fields[num-1]->type)
		{			int dd, mm, yy;			char *str;			double number;			case FT_CHARS:				str = prep_chars ((const char *)data, db->fields[num-1]->length);				if (str != NULL) {					fwrite (str, sizeof (UCHAR), db->fields[num-1]->length, db->fp);					free (str);				} else {					rc = E_ALLOC;				}				break;			case FT_DATE:				dd = mm = yy = 0;				sscanf (data, "%d%*c%d%*c%d", &dd, &mm, &yy);				str = prep_date (dd, mm, yy);				if (str != NULL) {					fwrite (str, sizeof (UCHAR), db->fields[num-1]->length, db->fp);					free (str);				} else {					rc = E_ALLOC;				}				break;			case FT_FLOAT:			case FT_NUMBER:				number = 0;				sscanf (data, "%20lf", &number);				str = prep_number (number, db->fields[num-1]->length,						db->fields[num-1]->dec_num);				if (str != NULL) {					fwrite (str, sizeof (UCHAR), db->fields[num-1]->length, db->fp);					free (str);				} else {					rc = E_ALLOC;				}				break;			case FT_BOOLEAN:				str = (char *) malloc (1);				if (*data=='T' || *data=='t' || *data=='Y' || *data=='y') {					*str = 'T';					fwrite (str, sizeof (UCHAR), 1, db->fp);				} else if (					*data=='F' || *data=='f' || *data=='N' || *data=='n') {					*str = 'F';					fwrite (str, sizeof (UCHAR), 1, db->fp);				} else {					rc = FALSE;				}				free (str);				break;			case FT_MEMO:				if (db->memoflag != FALSE) {					DWORD ref;					char *entry;					ref = add_memo_entry (db, data);					if (ref > 0) {						entry = dword2str(ref);						fwrite(entry, sizeof(UCHAR), 10, db->fp);						free(entry);					} else {						fwrite("          ", sizeof(UCHAR), 10, db->fp);					}				}				break;			default:				#ifdef DEBUG				fprintf (stderr,					"dbChangeField(): Field type '%c' not supported until now\n", db->fields[num-1]->type);				#endif				rc = E_FLD_TYPE;				break;		}		/* go back .. */		fseek (db->fp, db->offset[num-1], SEEK_CUR);		return (rc);	}
	else
		return (E_HANDLE);}/* * delete or undelete a record in the xbase file "db" *   mode = TRUE -> delete a record *   mode = FALSE -> undelete a record */static int io_del_record (DBF *db, DWORD nr, int mode) {	char flag;	long int pos;	pos = ftell (db->fp);	if (nr != CURRENT) {		if (io_goto (db, nr) != TRUE)			return (FALSE);	}	if (mode == TRUE)		flag = DEL_FLAG;	else		flag = NOT_DEL_FLAG;	fputc (flag, db->fp);	fseek (db->fp, pos, SEEK_SET);	return (TRUE);}/* * delete a record, rnr = 0 will delelet the actuall record */int FAR EXPORT dbDelRecord (int handle, DWORD rnr) {	DBF *db;	db = num2db (handle);	if (db != NULL) {		if (!(db->access_mode & DB_WRITE)) {			#ifdef DEBUG			fprintf (stderr, "dbDelRecord(): can't do cause in 'ro' mode\n");			#endif			dberrno = E_WRONG_MODE;			return (FALSE);		}		if (io_del_record (db, rnr, TRUE) == TRUE) {			return (TRUE);		} else {			#ifdef DEBUG			fprintf (stderr, "dbDelRecord(): io_del_record doesn't return TRUE\n");			#endif			return (E_REC_NR);		}	}	return (E_HANDLE);}/* * undelete a record, rnr = 0 will undelete the actuall record */int FAR EXPORT dbUndelRecord (int handle, DWORD rnr) {	DBF *db;	db = num2db (handle);	if (db != NULL) {		if (!(db->access_mode & DB_WRITE)) {			dberrno = E_WRONG_MODE;			return (FALSE);		}		if (io_del_record (db, rnr, FALSE) == TRUE) {			return (TRUE);		} else {			return (E_REC_NR);		}	}	return (E_HANDLE);}/* * copy the record number src to record number dest, * if src = 0, copy the actuall record */static int cp_record (DBF *db, DWORD dest, DWORD src) {	long int pos;	char *buf;	buf = (char *) malloc (db->head->record_size);	if (buf == NULL) {		return (FALSE);	}	pos = db->current;	if (src != CURRENT) {		io_goto (db, src);	}	fread (buf, sizeof(char), db->head->record_size, db->fp);	io_goto (db, dest);	fwrite (buf, sizeof(char), db->head->record_size, db->fp);	io_goto (db, pos);	return (TRUE);}/* * check if a record is deleted or not */int FAR EXPORT dbIsDeleted (int handle , DWORD rnr) {	DBF *db;	db = num2db (handle);	if (db != NULL) {		return (io_is_del (db, rnr));	}	return (E_HANDLE);}/* * pack a xbase file */int FAR EXPORT dbPack (int handle) {	DBF *db;	DWORD first_del, last_undel;	db = num2db (handle);	if (db != NULL) {		if (!(db->access_mode & DB_WRITE)) {			return (E_WRONG_MODE);		}		if (db->head->num_of_recs == 0) {			/* it's a empty xbase  file .. no need to pack			 */			return (TRUE);		}		/*		 * here it's starts		 */		if (io_goto(db, 1) == TRUE) {			first_del = 1;			last_undel = db->head->num_of_recs;			/* find the next deleted record			 */			LOOP:			while (io_is_del(db, CURRENT) == FALSE) {				if (first_del < db->head->num_of_recs) {					if (io_wind(db, 1) != TRUE) {						first_del = 0;						break;					}					first_del++;				} else {					first_del = 0;					break;				}			}			if (first_del == 0) {				/* there where no deleted records ..				 */				goto END_LOOP;			}			if (first_del == db->head->num_of_recs) {				/* we are at the end				 */				goto LAST;			}			if (db->head->num_of_recs > 1) {				/* take the last undeleted record				 */				io_goto (db, last_undel);				while (io_is_del(db, CURRENT) == TRUE) {					if (last_undel > 1) {						if (io_wind(db, -1) != TRUE) {							last_undel = 0;							break;						}						last_undel--;					} else {						last_undel = 0;						break;					}				}				if (last_undel < first_del)					goto LAST;				cp_record (db, first_del, CURRENT);				fputc (DOS_EOF, db->fp);				db->head->num_of_recs--;				last_undel--;				first_del++;				if ((last_undel > 0) && (first_del <= db->head->num_of_recs)) {					io_goto(db, first_del);					goto LOOP;				} else {					goto END_LOOP;				}			}			LAST:			io_goto (db, first_del);			fputc (DOS_EOF, db->fp);			db->head->num_of_recs = first_del - 1;			END_LOOP:			update_header (db);			return (TRUE);		}		return (FALSE);	} else {		return (E_HANDLE);	}}/* * restore the header and move the DOS_EOF to the real end of file * it behaves like a "unpack" :) */int FAR EXPORT dbRestore (int handle) {	DBF *db;	db_header *h;	struct stat buf;	DWORD size;	db = num2db(handle);	if (db != NULL) {		if (!(db->access_mode & DB_WRITE)) {			return (E_WRONG_MODE);		}		h = db->head;		stat (db->file_name, &buf);		size = buf.st_size - (h->header_size + h->record_size * h->num_of_recs);		if (size > h->record_size) {			fseek (db->fp, h->header_size + h->record_size * h->num_of_recs, SEEK_SET);			fputc (DEL_FLAG, db->fp);		}		while (size > h->record_size) {			h->num_of_recs++;			size -= h->record_size;		}		fseek (db->fp, h->header_size + h->record_size * h->num_of_recs, SEEK_SET);		fputc (DOS_EOF, db->fp);		update_header(db);		return (TRUE);	}	return (E_HANDLE);}/* * copy selected fields to a new xbase file */int FAR EXPORT dbCopyToFile (int handle, WORD *flds, WORD num, char *fname) {	DBF *db, *db2;	UCHAR *s, *memo;	UCHAR p[11];	WORD nob, i;	int rc, all;	db = num2db (handle);	if (db != NULL) {		if (num == 0) {			all = TRUE;			num = db->num_of_fields;			flds = (WORD *) malloc (sizeof(WORD) * num);			for (i = 0; i < num; i++)				flds[i] = i+1;		} else {			all = FALSE;		}		rc = dbCreate (fname, num, 0x03);		if (rc <= 0) {			return (FALSE);		}		db2 = num2db(rc);		for (i=0; i < num; i++) {			dbInitField(db2->handle, i+1, db->fields[flds[i]-1]->name,				db->fields[flds[i]-1]->type, db->fields[flds[i]-1]->length,				db->fields[flds[i]-1]->dec_num);		}#ifdef DEBUG		dump_header(db2);		fprintf(stderr, "*** %s\n", db2->file_name);#endif		io_goto (db, 1);		io_goto (db2, 1);		while ((s = io_raw_next(db, &nob)) != NULL) {			if (*s != DEL_FLAG) {				db_raw_write(db2, s, 1);				for (i = 0; i < num; i++) {					db_raw_write(db2, s+db->offset[flds[i]-1],									db->fields[flds[i]-1]->length);					/* handling of memo fields					 */					if (db->fields[flds[i]-1]->type == FT_MEMO) {							p[10] = '\0';							memcpy (p, s+db->offset[flds[i]-1], 10);							get_memo (db->memo, atoi((const char*)p), &memo);							add_memo_entry (db2, (char *)memo);							free (memo);					}				}				db2->head->num_of_recs++;			}			free(s);		}		db2->head->transaction = 0;		update_header(db2);		fputc (DOS_EOF, db2->fp);		fclose (db2->fp);		if (all == TRUE)			free (flds);		return (TRUE);	}	return (E_HANDLE);}/* */char FAR EXPORT dbDefDateSep (void) {	return (DEF_DATE_SEPERATOR);}/* */char FAR EXPORT *dbLastUpdate(int handle) {	DBF *db;	char *s;	db = num2db(handle);	if (db == NULL)		return (NULL);	s = (char *) malloc (11);	if (s != NULL) {		sprintf (s, "%02d%c%02d%c%02d",			db->head->lm_dd, DEF_DATE_SEPERATOR, db->head->lm_mm,			DEF_DATE_SEPERATOR, db->head->lm_yy);	}	return (s);}/* * not used until now */int dbUseIndex (int handle, char *fname, int mode) {	DBF *db;	FILE *fp;	const char *fmode;	struct stat finfo;	db = num2db(handle);	if (db == NULL) {		return (E_HANDLE);	}	if (stat (fname, &finfo) != 0) {		perror(fname);		return (E_IO);	}#if defined (linux) || defined (unix)	if (S_ISLNK(finfo.st_mode) || S_ISREG(finfo.st_mode)) {#else   /* DOS */	if ((finfo.st_mode & S_IFREG) || (finfo.st_mode == 0x0)) {#endif		if (finfo.st_size < 512) {			return (E_HEADER);		}	} else {		return (E_IO);	}	/* ok, let's open the file .. */	if (mode & DB_WRITE)		fmode = "rb+";	else		fmode = "rb";	if ((fp = fopen (fname, fmode)) != NULL) {		if (db->idx != NULL) {			/* there must be an other index file open			   close it before .. */			fclose(db->idx->fp);		} else {			db->idx = (db_index *) malloc (sizeof (db_index));		}		if (db->idx == NULL) {			fclose(fp);			return (E_ALLOC);		}		db->idx->fp = fp;		/* */		return (TRUE);	}	perror(fname);	return (E_IO);}/* * dump the header to STDERR */int dbDumpHeader (int handle) {	DBF *db;	db = num2db (handle);	if (db != NULL) {		dump_header (db);		return (TRUE);	}	return (E_HANDLE);}#ifdef WINDLLint FAR LibMain (HANDLE hInstance, WORD wDataSeg, WORD wHeapSize,						LPSTR lpszCmdLine) {	if (wHeapSize > 0)		UnlockData(0);	return (1);}int FAR EXPORT WEP (int nParam) {	if ((nParam == WEP_FREE_DLL) || (nParam == WEP_SYSTEM_EXIT)) {		/* close all open files		 */		while (first != NULL) {			MessageBox ((HWND)0, "closing stale file", LIBNAME, MB_ICONEXCLAMATION);			dbClose(first->handle);		}	}	return (1);}/* */void onerror (const char *s) {	char mesg_buf[2048];		sprintf (mesg_buf, "%s: %s", s, strerror(errno));	MessageBox ((HWND)0, s, "Error", MB_ICONEXCLAMATION);}#endif