/* * a2dbf 0.4, converts an ascii file to a xbase file * only string fields are supported! * published under the GNU General Public License, see COPYING * * rasca gmelch, berlin 1995, 1996 (rasca@marie.physik.tu-berlin.de) */#include <stdlib.h>#include <string.h>	/* strtok() */#if defined (linux) || defined (unix)	#include <getopt.h>	/* getopt(), optarg */#else	#include "getopt.h"#endif#include "dbf.h"#define SEPERATOR	';'				/* default field seperator */#define VERSION		"0.4"#define MAX_LINE	65536			/* should be enough :) */#define MAX_FIELDS	256#define NAME_LEN	10#define DEF_FILE_NAME	"a2dbf.dbf"	/* default file name */#define IS_STDIN	1#define IS_STDOUT	2#define IS_FILE		3#define max(a,b) ((a) > (b) ? (a) : (b))#define min(a,b) ((a) < (b) ? (a) : (b))char *mystrtok (char *s, char *delim);/* */void usage (char *pname) {	fprintf (stderr, " %s Version %s, published under the GNU GPL\n",		pname, VERSION);	fprintf (stderr, " Usage: %s [-s field_seperator] [-o outfile] ascii_file\n",		pname);	fprintf (stderr, " if 'outfile' is omitted a2dbf writes to 'out.dbf'\n");	exit (1);}/* */int StripEofLine(char *line) {	int found = 0;	while (*line) {		if ((*line == '\r') || (*line == '\n')) {			*line = '\0';			found = 1;			break;		}		line++;	}	return (found);}/* */int main (int argc, char *argv[]) {	FILE *fp;	int db, c, num, i, inmethod, nr, delimlen;	char sep;	char *file = NULL;	char line[MAX_LINE];	char delim[80];	UCHAR field[MAX_FIELDS][NAME_LEN+1];	unsigned int length[MAX_FIELDS];	char *p;	const char *outfile;	sep = SEPERATOR;	sprintf (delim, "%c", sep);	outfile = DEF_FILE_NAME;	inmethod = IS_FILE;	while ((c = getopt(argc, argv, "?s:o:")) != -1) {		switch (c) {			case '?':	usage(argv[0]);						break;			case 's':	if (*optarg == '\\') {							switch (*(optarg+1)) {								case 't': sep = '\t'; break;								case 'r': sep = '\r'; break;								case 'n': sep = '\n'; break;							}							sprintf (delim, "%c", sep);						} else {							sprintf (delim, "%s", optarg);						}						break;			case 'o':	outfile = optarg;						break;			default:	usage(argv[0]);						break;		}	}	if ((argc > 1) && (optind == argc -1)) {		file = argv[optind++];		fp = fopen (file, "rb");	} else {		fp = stdin;		inmethod = IS_STDIN;	}	if (fp == NULL) {		perror (file);		usage (argv[0]);	}	/*	 * read the first line with the fieldnames	 */	fgets (line, MAX_LINE, fp);	if (!StripEofLine(line))		fprintf (stderr, "warning: end of line not found\n");	if (*line == '\0') {		fprintf (stderr, "error: first line is empty!\n");		usage (argv[0]);	}	num = 1;	p = strtok (line, delim);	if (p == NULL) {		/* we have only one field		 */		strncpy ((char*) field[0], line, NAME_LEN+1);	} else {		strncpy ((char*) field[0], p, NAME_LEN+1);		while ((p = strtok (NULL, delim)) != NULL) {			num++;			strncpy ((char*) field[num-1], p, NAME_LEN+1);		} 	}	num = min (num, MAX_FIELDS);	db = dbCreate (outfile, num, DB_DBASE3);	if (db == 0) {		perror(outfile);		exit (2);	}	for (i = 0; i < num; i++) {		length[i] = 1;	/* every field has to be at least 1 byte long */	}	if (inmethod != IS_STDIN) {		int pos;		/* we can read twice for calculating the field sizes		 */		pos = ftell (fp);		while (fgets (line, MAX_LINE, fp)) {			StripEofLine(line);			p = mystrtok (line, delim);			length[0] = max (length[0], strlen (p));			for (i = 1; i < num; i++) {				p = mystrtok (NULL, delim);				if (p == NULL) {					i = num;				} else {					length[i] = max (length[i], strlen (p));				}			}		}		for (i = 0; i < num; i++) {			if (length[i] > 254) {				dbInitField (db, i+1, field[i], FT_MEMO, 10, 0);			} else {				dbInitField (db, i+1, field[i], FT_CHARS, length[i], 0);			}		}		/* go back to the first record */		fseek (fp, pos, SEEK_SET);	} else {		/* for stdin it's a dirty hack :-(( cause of the fixed field length		 */		for (i = 0; i < num; i++) {			dbInitField (db, i+1, field[i], FT_CHARS, 20, 0);		}	}	/* ok, let's do it	 */	delimlen = strlen (delim);	while (fgets (line, MAX_LINE, fp)) {		StripEofLine(line);		p = mystrtok (line, delim);		if ((p != NULL) && (p != '\0')) {			nr = dbAppendBlank (db);			dbChangeField (db, nr, 1, p);			for (i = 1; i < num; i++) {				p = mystrtok (NULL, delim);				if (p == NULL) {					/* it's a emtpy field at the end */					p = (char *) "";				}				dbChangeField (db, nr, i+1, p);			}		}	}	dbClose (db);	fclose (fp);	return (0);}