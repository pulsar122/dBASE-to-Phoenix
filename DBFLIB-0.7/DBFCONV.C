/* * dbfconv 0.5b, xbase file converter * published under the GNU General Public License, see COPYING * * rasca gmelch, berlin 1995, 1996 * (rasca@marie.physik.tu-berlin.de) */#include <stdlib.h>#include <string.h>		/* strlen() */#if defined (linux) || defined (unix)	#include <getopt.h> /* getopt(), optarg */	#define EOL "\n"#else	/* MS-DOS */	#include "getopt.h"	#define EOL "\r\n"#endif#include "dbf.h"#define SEPERATOR ';'#define VERSION "0.5b"enum {	ASCII,	LATEX,	HTML,	HTML_LIST};typedef struct {	DWORD first;      /* number of the first record */	DWORD last;       /* number of the last record */	int nof;        /* number of fields */	int fn[1024];   /* field numbers */	int record;     /* field number */	int usememo;     /* use memo files  */	int print_rnr;	/* print record number */	char fixed;		/* fixed field length */	char sep;       /* seperator */	char *eol;      /* end of line string */	char *fname;    /* file name */} data;	void usage (void) {	fprintf (stderr, " DBFCONV, version %s with %s, published under the GNU GPL\n", VERSION, DBF_LIB_VERSION);	fprintf (stderr, " Usage: dbfconv [-?lHhi] [-n #] [-s char] [-r string] file\n");	fprintf (stderr, " l: LaTeX output, tabular enviroment (default: ASCII)\n");	fprintf (stderr, " H: raw HTML output without header etc. (only <UL> and <LI> tags)\n");	fprintf (stderr, " h: HTML output (<TABLE> tags, only for HTML 3.0 or newer)\n");	fprintf (stderr, " i: ignore deleted (default: show deleted records)\n");	fprintf (stderr, " m: use memo files if exists (default = no)\n");	fprintf (stderr, " n: start at record number 'n' (1 = first)\n");	fprintf (stderr, " s: character, which should be used as seperator (default: '%c')\n", SEPERATOR);	fprintf (stderr, " p: print the record number in front of the line\n");	fprintf (stderr, " r: string, which should be used as record seperator (default: EOL)\n");	fprintf (stderr, " f: fixed field length, the field length is preserved\n");	fprintf (stderr, "    the '-r' and the '-f' option work only in ASCII mode!\n");	exit (1);}int tex_trans (const UCHAR *p) {	while (*p) {		switch (*p) {			case '%':			case '_':   printf ("\\%c", *p);					break;			default:    putchar (*p);						break;		}		p++;	}	return (0);}int to_latex (int db, data* d) {	int nof, i;	long int first, last, pos;	UCHAR type;	UCHAR *line;	first = d->first;	last = d->last;	nof = d->nof;	printf ("%%%%LaTeX\n%%%%\n");	printf ("\\documentstyle[10pt,a4,german,umlaut]{article}\n");	printf ("\\topmargin -0.04cm\n\\oddsidemargin -0.54cm\n\n");	printf ("\\begin{document}\n\n");	printf ("\\begin{tabular}{");	for (i=0; i < nof; i++) {		type = dbGetFieldType (db, i+1);		switch (type) {			case FT_NUMBER:			case FT_FLOAT:			case FT_MEMO:       putchar ('r');								break;			case FT_BOOLEAN:    putchar ('c');								break;			default:            putchar ('l');								break;		}	}	printf ("}\n");	for (i=0; i < nof; i++) {		tex_trans (dbGetFieldName (db, i+1));		if (i+1 < nof)			printf ("%c", '&');		else			printf ("\\\\\n");	}	dbGotoNr (db, first);	pos = first -1;	while ((line = dbTrStrNext (db, '&')) != NULL) {		pos++;		if ((last > 0) && (pos > last))			break;		if (*line != '\0') {			if (d->print_rnr)				printf ("%ld:", pos);			tex_trans (line);			printf ("\\\\\n");		}		free (line);	}	printf ("\\end{tabular}\n\n");	printf ("\\end{document}\n\n");	return (0);}int to_html (int db, data *da) {	int i, nof;	long int first, last, num;	UCHAR *line;	int igndel;	first = da->first;	last = da->last;	nof = da->nof;	printf ("<!doctype HTML PUBLIC -//W3C//DTD HTML 3.2//EN>\n");	printf ("<HTML>\n<HEAD>\n<TITLE>%s</TITLE>\n</HEAD>\n<BODY>\n", da->fname);	printf ("<TABLE BORDER=1>");	printf ("<CAPTION>%s</CAPTION>\n", da->fname);	printf ("<TR>");	for (i=0; i < nof; i++) {		printf ("<TH>%s", dbGetFieldName (db, i+1));	}	puts ("\n");	if (da->record != 0) {		dbGotoNr (db, da->record);		num = 1;	} else {		dbGotoNr (db, first);		num = last - (first - 1);	}	if (dbGetMode(db) & DB_IGNORE_DEL)		igndel = TRUE;	else		igndel = FALSE;	while (num--) {		if ((igndel == FALSE) || (dbIsDeleted(db, CURRENT) == FALSE)) {			puts ("<TR>");			for (i = 0; i < nof; i++) {				line = dbTrSelByNumber (db, i+1, 0);				if (*line != '\0')					printf ("<TD>%s\n", line);				else					puts ("<TD>-");				free(line);			}			putchar ('\n');		}		dbWind (db, 1);	}	puts ("</TABLE>\n</BODY>\n</HTML>");	return (0);}int to_html_list (int db, data *da) {	long int first, last, num;	int i, nof;	char sep;	UCHAR *line;	sep = da->sep;	nof = da->nof;	first = da->first;	last = da->last;	printf ("<UL>\n<LH>");	for (i=0; i < nof; i++) {		if (i > 0) {			putchar (sep);			putchar (' ');		}		printf ("%s", dbGetFieldName (db, i+1));	}	puts ("\n");	dbGotoNr (db, first);	num = last - (first - 1);	while (num--) {		printf ("<LI>");		for (i = 0; i < nof; i++) {			if (i > 0) {				putchar (sep);				putchar (' ');			}			line = dbTrSelByNumber (db, i+1, 0);			printf ("%s", line);			free(line);		}		putchar ('\n');		dbWind (db, 1);	}	puts ("</UL>\n");	return (0);}int to_ascii (int db, data *da) {	DWORD first = da->first;	DWORD last = da->last;	DWORD pos;	char sep = da->sep;	char *sepout = da->eol;	int nof, i;	UCHAR *line;	nof = da->nof;	for (i=0; i < nof; i++) {		printf ("%s", dbGetFieldName (db, i+1));		if (i+1 < nof)			putchar (sep);	}	printf ("%s", sepout);	dbGotoNr (db, first);	pos = first-1;	while ((line = dbTrStrNext (db, sep)) != NULL) {		#ifdef DEBUG2		if (*line == '\0') {			fprintf (stderr, "DEBUG2> pos: %d is empty\n", pos);		}		#endif		pos++;		if (pos > last)			break;		if (*line != '\0') {			if (da->print_rnr)				printf ("%ld:%s%s", pos, line, sepout);			else				printf ("%s%s", line, sepout);		}		free (line);	}	return (0);}int to_ascii_fixed (int db, data *da) {	DWORD first = da->first;	DWORD last =da->last;	DWORD pos;	char *sepout = da->eol;	char sep = da->sep;	UCHAR *s, *line;	int nof = da->nof;	int i;	for (i=0; i< nof; i++) {		s = dbGetExFieldName(db, i+1);		printf ("%s", s);		if (i+1 < nof)			putchar (sep);		free (s);	}	printf ("%s", sepout);	dbGotoNr (db, first);	pos = first-1;	while ((line = dbStrNext (db, sep)) != NULL) {		pos++;		if (pos > last)			break;		if (*line != '\0') {			printf ("%s%s", line, sepout);		}		free (line);	}	return (0);}int main (int argc, char *argv[]) {	int db, c, mode, igndel;	char *file;	data d;	d.first = 1;	d.last = 0;	d.sep = SEPERATOR;	d.eol = NULL;	d.record = 0;	d.usememo = FALSE;	d.fixed = FALSE;	d.print_rnr = FALSE;	file = NULL;	mode = ASCII;	igndel = 0;	while ((c = getopt(argc, argv, "?hHiflpn:N:S:s:r:m")) != -1) {		switch (c) {			case '?':   usage();						break;			case 'f':	d.fixed = TRUE;						break;			case 'l':   mode = LATEX;						break;			case 'h':   mode = HTML;						break;			case 'H':   mode = HTML_LIST;						break;			case 'm':   d.usememo = TRUE;						break;			case 'n':   d.first = atoi (optarg);						break;			case 'N':   d.record = atoi (optarg);						break;			case 'S':   d.last = atoi (optarg);						break;			case 's':   if (*optarg == '\\') {							switch (*(optarg+1)) {								case 't': d.sep = '\t'; break;								case 'r': d.sep = '\r'; break;								case 'n': d.sep = '\n'; break;							}						} else {							d.sep = *optarg;						}						break;			case 'i':   igndel = 1;						break;			case 'r':   d.eol = (char *) malloc (strlen (optarg) +1);						sprintf (d.eol, "%s", optarg);						break;			case 'p':	d.print_rnr = TRUE;						break;			default:    usage();						break;		}	}	if ((argc > 1) && (optind == argc -1)) {		file = argv[optind++];		d.fname = file;	} else {		usage();	}	if (d.usememo == TRUE) {		db = dbOpen (file, DB_READ);	} else {		db = dbOpen (file, DB_READ | DB_IGNORE_MEMO);	}	if (db > 0) {		d.nof = dbGetNumOfFields (db);		if (d.last == 0) {			d.last = dbGetNumOfRecs (db);		}		if (d.last > dbGetNumOfRecs (db)) {			d.last = dbGetNumOfRecs (db);		}		if (d.first > dbGetNumOfRecs (db)) {			d.first = dbGetNumOfRecs (db);		}		if (igndel) {			dbSetShowDel (db, FALSE);		} else {			dbSetShowDel (db, TRUE);		}		if (d.eol == NULL) {			d.eol = (char *) malloc (strlen (EOL) +1);			sprintf (d.eol, "%s", EOL);		}		switch (mode) {			case ASCII: if (d.fixed == TRUE) {							to_ascii_fixed (db, &d);						} else {							to_ascii (db, &d);						}						break;			case LATEX: to_latex (db, &d);						break;			case HTML:  to_html (db, &d);						break;			case HTML_LIST: to_html_list (db, &d);						break;			default:    printf ("mode not supported until now :)\n");						exit (2);		}		dbClose (db);		free (d.eol);	} else {		printf ("error when calling open_dbf()\n");	}	return (0);}